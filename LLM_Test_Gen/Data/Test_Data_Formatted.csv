"FQN","Signature","Jimple Code Representation","Generated Code","Code After Formatting","Saved Path"
"org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String)","java.lang.String uncapitalize(java.lang.String)","{
    java.lang.String str;
    unknown $stack1;


    str := @parameter0: java.lang.String;
    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String,char[])>(str, null);

    return $stack1;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils uncapitalize method.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test uncapitalizing a single capitalized word"")
    void testUncapitalizeSingleWord() {
        assertEquals(""word"", wordUtils.uncapitalize(""Word""), ""Uncapitalize 'Word' should result in 'word'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a sentence with multiple capitalized words"")
    void testUncapitalizeSentence() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World""), ""Uncapitalize 'Hello World' should result in 'hello world'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a sentence with mixed case"")
    void testUncapitalizeMixedCase() {
        assertEquals(""hello World"", wordUtils.uncapitalize(""Hello World""), ""Uncapitalize 'Hello World' should result in 'hello World'"");
    }

    // EDGE CASES (Input Content)

    @Test
    @DisplayName(""Test uncapitalizing an empty string"")
    void testUncapitalizeEmptyString() {
        assertEquals("""", wordUtils.uncapitalize(""""), ""Uncapitalize of empty string should be empty string"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with all lowercase letters"")
    void testUncapitalizeAllLowercase() {
        assertEquals(""word"", wordUtils.uncapitalize(""word""), ""Uncapitalize 'word' should result in 'word'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with all uppercase letters"")
    void testUncapitalizeAllUppercase() {
        assertEquals(""uppercase"", wordUtils.uncapitalize(""UPPERCASE""), ""Uncapitalize 'UPPERCASE' should result in 'uppercase'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with numbers and symbols"")
    void testUncapitalizeWithNumbersAndSymbols() {
        assertEquals(""word123!!!"", wordUtils.uncapitalize(""Word123!!!""), ""Uncapitalize 'Word123!!!' should result in 'word123!!!'"");
    }

    // ERROR CASES (Invalid Input)

    @Test
    @DisplayName(""Test uncapitalizing a null string"")
    void testUncapitalizeNull() {
        String str = null;
        assertNull(wordUtils.uncapitalize(str), ""Uncapitalize null should return null"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils uncapitalize method.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test uncapitalizing a single capitalized word"")
    void testUncapitalizeSingleWord() {
        assertEquals(""word"", wordUtils.uncapitalize(""Word""), ""Uncapitalize 'Word' should result in 'word'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a sentence with multiple capitalized words"")
    void testUncapitalizeSentence() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World""), ""Uncapitalize 'Hello World' should result in 'hello world'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a sentence with mixed case"")
    void testUncapitalizeMixedCase() {
        assertEquals(""hello World"", wordUtils.uncapitalize(""Hello World""), ""Uncapitalize 'Hello World' should result in 'hello World'"");
    }

    // EDGE CASES (Input Content)

    @Test
    @DisplayName(""Test uncapitalizing an empty string"")
    void testUncapitalizeEmptyString() {
        assertEquals("""", wordUtils.uncapitalize(""""), ""Uncapitalize of empty string should be empty string"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with all lowercase letters"")
    void testUncapitalizeAllLowercase() {
        assertEquals(""word"", wordUtils.uncapitalize(""word""), ""Uncapitalize 'word' should result in 'word'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with all uppercase letters"")
    void testUncapitalizeAllUppercase() {
        assertEquals(""uppercase"", wordUtils.uncapitalize(""UPPERCASE""), ""Uncapitalize 'UPPERCASE' should result in 'uppercase'"");
    }

    @Test
    @DisplayName(""Test uncapitalizing a string with numbers and symbols"")
    void testUncapitalizeWithNumbersAndSymbols() {
        assertEquals(""word123!!!"", wordUtils.uncapitalize(""Word123!!!""), ""Uncapitalize 'Word123!!!' should result in 'word123!!!'"");
    }

    // ERROR CASES (Invalid Input)

    @Test
    @DisplayName(""Test uncapitalizing a null string"")
    void testUncapitalizeNull() {
        String str = null;
        assertNull(wordUtils.uncapitalize(str), ""Uncapitalize null should return null"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int, java.lang.String, boolean)","java.lang.String wrap(java.lang.String, int, java.lang.String, boolean)","{
    boolean wrapLongWords;
    int wrapLength;
    java.lang.String newLineStr, str;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, $stack18, $stack19, $stack20, $stack21, $stack22, $stack23, $stack24, $stack25, $stack26, $stack27, $stack28, $stack29, $stack30, $stack31, $stack32, $stack33, $stack34, $stack35, $stack36, $stack37, $stack38, $stack8, $stack9, inputLineLength, offset, spaceToWrapAt, wrappedLine;


    str := @parameter0: java.lang.String;
    wrapLength := @parameter1: int;
    newLineStr := @parameter2: java.lang.String;
    wrapLongWords := @parameter3: boolean;

    if str != null goto label01;

    return null;

  label01:
    if newLineStr != null goto label02;
    newLineStr = <org.apache.commons.lang3.SystemUtils: java.lang.String LINE_SEPARATOR>;

  label02:
    $stack38 = wrapLength;
    $stack37 = 1;

    if $stack38 >= $stack37 goto label03;
    wrapLength = 1;

  label03:
    $stack32 = str;
    $stack33 = virtualinvoke str.<java.lang.String: int length()>();
    $stack34 = 0;
    offset = $stack34;
    $stack8 = new java.lang.StringBuilder;
    $stack36 = inputLineLength;
    $stack35 = 32;
    $stack9 = $stack36 + $stack35;
    specialinvoke $stack8.<java.lang.StringBuilder: void <init>(int)>($stack9);
    wrappedLine = $stack8;

  label04:
    $stack20 = inputLineLength;
    $stack19 = offset;
    $stack10 = $stack20 - $stack19;
    $stack21 = wrapLength;

    if $stack10 <= $stack21 goto label10;
    $stack14 = virtualinvoke str.<java.lang.String: char charAt(int)>(offset);

    if $stack14 != 32 goto label05;
    offset = offset + 1;

    goto label04;

  label05:
    $stack15 = wrapLength + offset;
    spaceToWrapAt = virtualinvoke str.<java.lang.String: int lastIndexOf(int,int)>(32, $stack15);

    if spaceToWrapAt < offset goto label06;
    $stack29 = virtualinvoke str.<java.lang.String: java.lang.String substring(int,int)>(offset, spaceToWrapAt);
    $stack30 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack29);
    $stack31 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);
    offset = spaceToWrapAt + 1;

    goto label09;

  label06:
    if wrapLongWords == 0 goto label07;
    $stack25 = wrapLength + offset;
    $stack26 = virtualinvoke str.<java.lang.String: java.lang.String substring(int,int)>(offset, $stack25);
    $stack27 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack26);
    $stack28 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);
    offset = offset + wrapLength;

    goto label09;

  label07:
    $stack16 = wrapLength + offset;
    spaceToWrapAt = virtualinvoke str.<java.lang.String: int indexOf(int,int)>(32, $stack16);

    if spaceToWrapAt < 0 goto label08;
    $stack22 = virtualinvoke str.<java.lang.String: java.lang.String substring(int,int)>(offset, spaceToWrapAt);
    $stack23 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack22);
    $stack24 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);
    offset = spaceToWrapAt + 1;

    goto label09;

  label08:
    $stack17 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);
    $stack18 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack17);
    offset = inputLineLength;

  label09:
    goto label04;

  label10:
    $stack11 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);
    $stack12 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack11);
    $stack13 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.String toString()>();

    return $stack13;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test wrapping a normal sentence with non-breaking space"")
    void testWrapNormalSentence() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick\nbrown fox\njumps over\nthe lazy\ndog"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping a normal sentence allowing breaking long words"")
    void testWrapNormalSentenceBreakingLongWords() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick\nbrown fox\njumps over\nthe lazy\ndog"", 
            wordUtils.wrap(str, 10, ""\n"", true));
    }

    @Test
    @DisplayName(""Test wrapping a sentence with custom new line"")
    void testWrapWithCustomNewLine() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick*brown fox*jumps over*the lazy*dog"", 
            wordUtils.wrap(str, 10, ""*"", false));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test wrapping a single word without breaking"")
    void testSingleWordNoBreak() {
        String str = ""Supercalifragilisticexpialidocious"";
        assertEquals(""Supercalifragilisticexpialidocious"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping a single long word with breaking"")
    void testSingleWordBreak() {
        String str = ""Supercalifragilisticexpialidocious"";
        assertEquals(""Supercalif\nragilistic\necpialidoc\nious"", 
            wordUtils.wrap(str, 10, ""\n"", true));
    }

    @Test
    @DisplayName(""Test wrapping with wrap length longer than string length"")
    void testWrapLongerThanString() {
        String str = ""Short"";
        assertEquals(""Short"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test wrapping with null string"")
    void testWrapNullString() {
        assertNull(wordUtils.wrap(null, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with empty string"")
    void testWrapEmptyString() {
        assertEquals("""", wordUtils.wrap("""", 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with wrap length less than 1"")
    void testWrapLengthLessThanOne() {
        String str = ""Wordtools testing"";
        assertEquals(""Wordtools\ntesting"", 
            wordUtils.wrap(str, 0, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with null new line string"")
    void testWrapNullNewLine() {
        String str = ""Wordtools testing handling"";
        assertEquals(""Wordtools"" + System.lineSeparator() + ""testing"" + System.lineSeparator() + ""handling"", 
            wordUtils.wrap(str, 10, null, false));
    }

    @Test
    @DisplayName(""Test wrapping an already wrapped string"")
    void testWrapAlreadyWrapped() {
        String str = ""Already\nwrapped\ntext"";
        assertEquals(""Already\nwrapped\ntext"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test wrapping a normal sentence with non-breaking space"")
    void testWrapNormalSentence() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick\nbrown fox\njumps over\nthe lazy\ndog"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping a normal sentence allowing breaking long words"")
    void testWrapNormalSentenceBreakingLongWords() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick\nbrown fox\njumps over\nthe lazy\ndog"", 
            wordUtils.wrap(str, 10, ""\n"", true));
    }

    @Test
    @DisplayName(""Test wrapping a sentence with custom new line"")
    void testWrapWithCustomNewLine() {
        String str = ""The quick brown fox jumps over the lazy dog"";
        assertEquals(""The quick*brown fox*jumps over*the lazy*dog"", 
            wordUtils.wrap(str, 10, ""*"", false));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test wrapping a single word without breaking"")
    void testSingleWordNoBreak() {
        String str = ""Supercalifragilisticexpialidocious"";
        assertEquals(""Supercalifragilisticexpialidocious"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping a single long word with breaking"")
    void testSingleWordBreak() {
        String str = ""Supercalifragilisticexpialidocious"";
        assertEquals(""Supercalif\nragilistic\necpialidoc\nious"", 
            wordUtils.wrap(str, 10, ""\n"", true));
    }

    @Test
    @DisplayName(""Test wrapping with wrap length longer than string length"")
    void testWrapLongerThanString() {
        String str = ""Short"";
        assertEquals(""Short"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test wrapping with null string"")
    void testWrapNullString() {
        assertNull(wordUtils.wrap(null, 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with empty string"")
    void testWrapEmptyString() {
        assertEquals("""", wordUtils.wrap("""", 10, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with wrap length less than 1"")
    void testWrapLengthLessThanOne() {
        String str = ""Wordtools testing"";
        assertEquals(""Wordtools\ntesting"", 
            wordUtils.wrap(str, 0, ""\n"", false));
    }

    @Test
    @DisplayName(""Test wrapping with null new line string"")
    void testWrapNullNewLine() {
        String str = ""Wordtools testing handling"";
        assertEquals(""Wordtools"" + System.lineSeparator() + ""testing"" + System.lineSeparator() + ""handling"", 
            wordUtils.wrap(str, 10, null, false));
    }

    @Test
    @DisplayName(""Test wrapping an already wrapped string"")
    void testWrapAlreadyWrapped() {
        String str = ""Already\nwrapped\ntext"";
        assertEquals(""Already\nwrapped\ntext"", 
            wordUtils.wrap(str, 10, ""\n"", false));
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.swapCase(java.lang.String)","java.lang.String swapCase(java.lang.String)","{
    java.lang.String str;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack5, $stack6, $stack7, $stack8, $stack9, buffer, ch, i, whitespace;


    str := @parameter0: java.lang.String;
    $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack5 == 0 goto label1;

    return str;

  label1:
    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    whitespace = 1;
    i = 0;

  label2:
    $stack12 = i;
    $stack11 = buffer;
    $stack6 = lengthof $stack11;

    if $stack12 >= $stack6 goto label8;
    ch = buffer[i];
    $stack8 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(ch);

    if $stack8 == 0 goto label3;
    $stack16 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);
    buffer[i] = $stack16;
    whitespace = 0;

    goto label7;

  label3:
    $stack9 = staticinvoke <java.lang.Character: boolean isTitleCase(char)>(ch);

    if $stack9 == 0 goto label4;
    $stack15 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);
    buffer[i] = $stack15;
    whitespace = 0;

    goto label7;

  label4:
    $stack10 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(ch);

    if $stack10 == 0 goto label6;

    if whitespace == 0 goto label5;
    $stack14 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);
    buffer[i] = $stack14;
    whitespace = 0;

    goto label7;

  label5:
    $stack13 = staticinvoke <java.lang.Character: char toUpperCase(char)>(ch);
    buffer[i] = $stack13;

    goto label7;

  label6:
    whitespace = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);

  label7:
    i = i + 1;

    goto label2;

  label8:
    $stack7 = new java.lang.String;
    specialinvoke $stack7.<java.lang.String: void <init>(char[])>(buffer);

    return $stack7;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test swapping case for a typical sentence"")
    void testSwapCaseTypicalSentence() {
        assertEquals(""hELLO wORLD"", wordUtils.swapCase(""Hello World""), ""Swapping case in 'Hello World'"");
    }

    @Test
    @DisplayName(""Test swapping case with mixed case input"")
    void testSwapCaseMixedCase() {
        assertEquals(""mIxEd CaSe"", wordUtils.swapCase(""MiXeD cAsE""), ""Swapping case in 'MiXeD cAsE'"");
    }

    @Test
    @DisplayName(""Test swapping case with all uppercase input"")
    void testSwapCaseAllUppercase() {
        assertEquals(""lowercase"", wordUtils.swapCase(""LOWERCASE""), ""Swapping case in 'LOWERCASE'"");
    }

    @Test
    @DisplayName(""Test swapping case with all lowercase input"")
    void testSwapCaseAllLowercase() {
        assertEquals(""UPPERCASE"", wordUtils.swapCase(""uppercase""), ""Swapping case in 'uppercase'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test swapping case with single character input"")
    void testSwapCaseSingleCharacter() {
        assertEquals(""a"", wordUtils.swapCase(""A""), ""Swapping case in single character 'A'"");
        assertEquals(""A"", wordUtils.swapCase(""a""), ""Swapping case in single character 'a'"");
    }

    @Test
    @DisplayName(""Test swapping case with empty string input"")
    void testSwapCaseEmptyString() {
        assertEquals("""", wordUtils.swapCase(""""), ""Swapping case in empty string"");
    }

    @Test
    @DisplayName(""Test swapping case with numbers and special characters"")
    void testSwapCaseNumbersAndSpecialChars() {
        assertEquals(""12345!@#"", wordUtils.swapCase(""12345!@#""), ""Swapping case should not affect numbers or special chars"");
    }

    @Test
    @DisplayName(""Test edge case with whitespace"")
    void testSwapCaseWhiteSpace() {
        assertEquals("" "", wordUtils.swapCase("" ""), ""Swapping case for a single space should return the same space"");
        assertEquals(""\t\n"", wordUtils.swapCase(""\t\n""), ""Tabs and newlines should remain unaffected"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test swapping case when string starts with whitespace"")
    void testSwapCaseLeadingWhitespace() {
        assertEquals("" hello"", wordUtils.swapCase("" HELLO""), ""Leading whitespace should not be affected"");
    }

    @Test
    @DisplayName(""Test swapping case with mixed whitespace within a string"")
    void testSwapCaseMixedWhitespace() {
        assertEquals(""MiXeD\nCaSe\tExAmPlE"", wordUtils.swapCase(""mIxEd\ncAsE\tEXaMpLe""), ""Handle mixed whitespace correctly"");
    }

    @Test
    @DisplayName(""Test title case rule when whitespace precedes a character"")
    void testSwapCaseTitleCaseRule() {
        assertEquals(""Hello World"", wordUtils.swapCase(""hELLO wORLD""), ""Title case rule applies after whitespace"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test swapping case with a null string"")
    void testSwapCaseNull() {
        assertNull(wordUtils.swapCase(null), ""Swapping case on null should return null"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test swapping case for a typical sentence"")
    void testSwapCaseTypicalSentence() {
        assertEquals(""hELLO wORLD"", wordUtils.swapCase(""Hello World""), ""Swapping case in 'Hello World'"");
    }

    @Test
    @DisplayName(""Test swapping case with mixed case input"")
    void testSwapCaseMixedCase() {
        assertEquals(""mIxEd CaSe"", wordUtils.swapCase(""MiXeD cAsE""), ""Swapping case in 'MiXeD cAsE'"");
    }

    @Test
    @DisplayName(""Test swapping case with all uppercase input"")
    void testSwapCaseAllUppercase() {
        assertEquals(""lowercase"", wordUtils.swapCase(""LOWERCASE""), ""Swapping case in 'LOWERCASE'"");
    }

    @Test
    @DisplayName(""Test swapping case with all lowercase input"")
    void testSwapCaseAllLowercase() {
        assertEquals(""UPPERCASE"", wordUtils.swapCase(""uppercase""), ""Swapping case in 'uppercase'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test swapping case with single character input"")
    void testSwapCaseSingleCharacter() {
        assertEquals(""a"", wordUtils.swapCase(""A""), ""Swapping case in single character 'A'"");
        assertEquals(""A"", wordUtils.swapCase(""a""), ""Swapping case in single character 'a'"");
    }

    @Test
    @DisplayName(""Test swapping case with empty string input"")
    void testSwapCaseEmptyString() {
        assertEquals("""", wordUtils.swapCase(""""), ""Swapping case in empty string"");
    }

    @Test
    @DisplayName(""Test swapping case with numbers and special characters"")
    void testSwapCaseNumbersAndSpecialChars() {
        assertEquals(""12345!@#"", wordUtils.swapCase(""12345!@#""), ""Swapping case should not affect numbers or special chars"");
    }

    @Test
    @DisplayName(""Test edge case with whitespace"")
    void testSwapCaseWhiteSpace() {
        assertEquals("" "", wordUtils.swapCase("" ""), ""Swapping case for a single space should return the same space"");
        assertEquals(""\t\n"", wordUtils.swapCase(""\t\n""), ""Tabs and newlines should remain unaffected"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test swapping case when string starts with whitespace"")
    void testSwapCaseLeadingWhitespace() {
        assertEquals("" hello"", wordUtils.swapCase("" HELLO""), ""Leading whitespace should not be affected"");
    }

    @Test
    @DisplayName(""Test swapping case with mixed whitespace within a string"")
    void testSwapCaseMixedWhitespace() {
        assertEquals(""MiXeD\nCaSe\tExAmPlE"", wordUtils.swapCase(""mIxEd\ncAsE\tEXaMpLe""), ""Handle mixed whitespace correctly"");
    }

    @Test
    @DisplayName(""Test title case rule when whitespace precedes a character"")
    void testSwapCaseTitleCaseRule() {
        assertEquals(""Hello World"", wordUtils.swapCase(""hELLO wORLD""), ""Title case rule applies after whitespace"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test swapping case with a null string"")
    void testSwapCaseNull() {
        assertNull(wordUtils.swapCase(null), ""Swapping case on null should return null"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String)","java.lang.String capitalize(java.lang.String)","{
    java.lang.String str;
    unknown $stack1;


    str := @parameter0: java.lang.String;
    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String,char[])>(str, null);

    return $stack1;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class's capitalize method.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalizing a typical sentence"")
    void testCapitalizeTypicalSentence() {
        String result = WordUtils.capitalize(""the quick brown fox"");
        assertEquals(""The Quick Brown Fox"", result, ""Each word should start with an uppercase letter"");
    }

    @Test
    @DisplayName(""Test capitalizing a single word"")
    void testCapitalizeSingleWord() {
        String result = WordUtils.capitalize(""word"");
        assertEquals(""Word"", result, ""Single word should be capitalized"");
    }

    @Test
    @DisplayName(""Test capitalizing a sentence with mixed case"")
    void testCapitalizeMixedCase() {
        String result = WordUtils.capitalize(""tHe quICK broWN FoX"");
        assertEquals(""The Quick Brown Fox"", result, ""Should capitalize each word correctly even if mixed case"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalizing when input is already capitalized"")
    void testCapitalizeAlreadyCapitalized() {
        String result = WordUtils.capitalize(""Capitalized Sentence"");
        assertEquals(""Capitalized Sentence"", result, ""Capitalized words should remain unchanged"");
    }

    @Test
    @DisplayName(""Test capitalizing an empty string"")
    void testCapitalizeEmptyString() {
        String result = WordUtils.capitalize("""");
        assertEquals("""", result, ""Empty string should return an empty string"");
    }

    @Test
    @DisplayName(""Test capitalizing a string with single character words"")
    void testCapitalizeSingleCharacterWords() {
        String result = WordUtils.capitalize(""a b c"");
        assertEquals(""A B C"", result, ""Each single character should be capitalized"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test capitalizing a string with punctuation"")
    void testCapitalizeWithPunctuation() {
        String result = WordUtils.capitalize(""hello! is this word capitalized?"");
        assertEquals(""Hello! Is This Word Capitalized?"", result, ""Should handle punctuation correctly"");
    }

    @Test
    @DisplayName(""Test capitalizing a very long string"")
    void testCapitalizeVeryLongString() {
        String longString = ""a "".repeat(1000).trim();
        String expectedResult = ""A "".repeat(1000).trim();
        String result = WordUtils.capitalize(longString);
        assertEquals(expectedResult, result, ""Should handle very long strings correctly"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalizing a null string"")
    void testCapitalizeNullString() {
        String result = WordUtils.capitalize((String) null);
        assertNull(result, ""Capitalizing a null string should return null"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class's capitalize method.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalizing a typical sentence"")
    void testCapitalizeTypicalSentence() {
        String result = WordUtils.capitalize(""the quick brown fox"");
        assertEquals(""The Quick Brown Fox"", result, ""Each word should start with an uppercase letter"");
    }

    @Test
    @DisplayName(""Test capitalizing a single word"")
    void testCapitalizeSingleWord() {
        String result = WordUtils.capitalize(""word"");
        assertEquals(""Word"", result, ""Single word should be capitalized"");
    }

    @Test
    @DisplayName(""Test capitalizing a sentence with mixed case"")
    void testCapitalizeMixedCase() {
        String result = WordUtils.capitalize(""tHe quICK broWN FoX"");
        assertEquals(""The Quick Brown Fox"", result, ""Should capitalize each word correctly even if mixed case"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalizing when input is already capitalized"")
    void testCapitalizeAlreadyCapitalized() {
        String result = WordUtils.capitalize(""Capitalized Sentence"");
        assertEquals(""Capitalized Sentence"", result, ""Capitalized words should remain unchanged"");
    }

    @Test
    @DisplayName(""Test capitalizing an empty string"")
    void testCapitalizeEmptyString() {
        String result = WordUtils.capitalize("""");
        assertEquals("""", result, ""Empty string should return an empty string"");
    }

    @Test
    @DisplayName(""Test capitalizing a string with single character words"")
    void testCapitalizeSingleCharacterWords() {
        String result = WordUtils.capitalize(""a b c"");
        assertEquals(""A B C"", result, ""Each single character should be capitalized"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test capitalizing a string with punctuation"")
    void testCapitalizeWithPunctuation() {
        String result = WordUtils.capitalize(""hello! is this word capitalized?"");
        assertEquals(""Hello! Is This Word Capitalized?"", result, ""Should handle punctuation correctly"");
    }

    @Test
    @DisplayName(""Test capitalizing a very long string"")
    void testCapitalizeVeryLongString() {
        String longString = ""a "".repeat(1000).trim();
        String expectedResult = ""A "".repeat(1000).trim();
        String result = WordUtils.capitalize(longString);
        assertEquals(expectedResult, result, ""Should handle very long strings correctly"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalizing a null string"")
    void testCapitalizeNullString() {
        String result = WordUtils.capitalize((String) null);
        assertNull(result, ""Capitalizing a null string should return null"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String, char[])","java.lang.String capitalize(java.lang.String, char[])","{
    char[] delimiters;
    java.lang.String str;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack7, $stack8, $stack9, buffer, capitalizeNext, ch, delimLen, i;


    str := @parameter0: java.lang.String;
    delimiters := @parameter1: char[];

    if delimiters != null goto label1;
    $stack15 = -1;

    goto label2;

  label1:
    $stack15 = lengthof delimiters;

  label2:
    $stack16 = str;
    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>($stack16);

    if $stack7 != 0 goto label3;

    if delimLen != 0 goto label4;

  label3:
    $stack14 = str;

    return $stack14;

  label4:
    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    capitalizeNext = 1;
    i = 0;

  label5:
    $stack12 = i;
    $stack11 = buffer;
    $stack8 = lengthof $stack11;

    if $stack12 >= $stack8 goto label8;
    ch = buffer[i];
    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char,char[])>(ch, delimiters);

    if $stack10 == 0 goto label6;
    capitalizeNext = 1;

    goto label7;

  label6:
    if capitalizeNext == 0 goto label7;
    $stack13 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);
    buffer[i] = $stack13;
    capitalizeNext = 0;

  label7:
    i = i + 1;

    goto label5;

  label8:
    $stack9 = new java.lang.String;
    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);

    return $stack9;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalize with single delimiter"")
    void testCapitalizeSingleDelimiter() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hello world"", new char[] {' '}),
                ""Should capitalize words separated by space"");
    }

    @Test
    @DisplayName(""Test capitalize with multiple delimiters"")
    void testCapitalizeMultipleDelimiters() {
        assertEquals(""Hello-World"", wordUtils.capitalize(""hello-world"", new char[] {' ', '-'}),
                ""Should capitalize words separated by space and hyphen"");
    }

    @Test
    @DisplayName(""Test capitalize with no delimiters"")
    void testCapitalizeNoDelimiters() {
        assertEquals(""HelloWorld"", wordUtils.capitalize(""helloworld"", null), 
                ""Should capitalize first character when delimiters are null"");
    }

    @Test
    @DisplayName(""Test capitalize with mixed case input"")
    void testCapitalizeMixedCase() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hELLo WoRLd"", new char[] {' '}),
                ""Should capitalize words and ignore existing case"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalize with empty string"")
    void testCapitalizeEmptyString() {
        assertEquals("""", wordUtils.capitalize("""", new char[] {' '}), 
                ""Empty string should return empty"");
    }

    @Test
    @DisplayName(""Test capitalize with single character string"")
    void testCapitalizeSingleCharacterString() {
        assertEquals(""A"", wordUtils.capitalize(""a"", new char[] {' '}),
                ""Single character should be capitalized"");
    }

    @Test
    @DisplayName(""Test capitalize with delimiters not present in input"")
    void testCapitalizeDelimitersNotPresent() {
        assertEquals(""Hello"", wordUtils.capitalize(""hello"", new char[] {'-'}), 
                ""Should capitalize first character if delimiters are not present"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test capitalize when delimiters are non-alphabetic characters"")
    void testCapitalizeNonAlphabeticDelimiters() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hello.world"", new char[] {'.'}),
                ""Should capitalize words separated by non-alphabetic characters"");
    }

    @Test
    @DisplayName(""Test capitalize with consecutive delimiters"")
    void testCapitalizeConsecutiveDelimiters() {
        assertEquals(""Hello  World"", wordUtils.capitalize(""hello  world"", new char[] {' '}),
                ""Should handle consecutive delimiters correctly"");
    }

    @Test
    @DisplayName(""Test capitalize with empty delimiters array"")
    void testCapitalizeEmptyDelimiters() {
        assertEquals(""HelloWorld"", wordUtils.capitalize(""helloworld"", new char[] {}),
                ""Empty delimiters should return string capitalized at first character only"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalize with null string"")
    void testCapitalizeNullString() {
        assertNull(wordUtils.capitalize(null, new char[] {' '}),
                ""Null input string should return null"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalize with single delimiter"")
    void testCapitalizeSingleDelimiter() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hello world"", new char[] {' '}),
                ""Should capitalize words separated by space"");
    }

    @Test
    @DisplayName(""Test capitalize with multiple delimiters"")
    void testCapitalizeMultipleDelimiters() {
        assertEquals(""Hello-World"", wordUtils.capitalize(""hello-world"", new char[] {' ', '-'}),
                ""Should capitalize words separated by space and hyphen"");
    }

    @Test
    @DisplayName(""Test capitalize with no delimiters"")
    void testCapitalizeNoDelimiters() {
        assertEquals(""HelloWorld"", wordUtils.capitalize(""helloworld"", null), 
                ""Should capitalize first character when delimiters are null"");
    }

    @Test
    @DisplayName(""Test capitalize with mixed case input"")
    void testCapitalizeMixedCase() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hELLo WoRLd"", new char[] {' '}),
                ""Should capitalize words and ignore existing case"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalize with empty string"")
    void testCapitalizeEmptyString() {
        assertEquals("""", wordUtils.capitalize("""", new char[] {' '}), 
                ""Empty string should return empty"");
    }

    @Test
    @DisplayName(""Test capitalize with single character string"")
    void testCapitalizeSingleCharacterString() {
        assertEquals(""A"", wordUtils.capitalize(""a"", new char[] {' '}),
                ""Single character should be capitalized"");
    }

    @Test
    @DisplayName(""Test capitalize with delimiters not present in input"")
    void testCapitalizeDelimitersNotPresent() {
        assertEquals(""Hello"", wordUtils.capitalize(""hello"", new char[] {'-'}), 
                ""Should capitalize first character if delimiters are not present"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test capitalize when delimiters are non-alphabetic characters"")
    void testCapitalizeNonAlphabeticDelimiters() {
        assertEquals(""Hello World"", wordUtils.capitalize(""hello.world"", new char[] {'.'}),
                ""Should capitalize words separated by non-alphabetic characters"");
    }

    @Test
    @DisplayName(""Test capitalize with consecutive delimiters"")
    void testCapitalizeConsecutiveDelimiters() {
        assertEquals(""Hello  World"", wordUtils.capitalize(""hello  world"", new char[] {' '}),
                ""Should handle consecutive delimiters correctly"");
    }

    @Test
    @DisplayName(""Test capitalize with empty delimiters array"")
    void testCapitalizeEmptyDelimiters() {
        assertEquals(""HelloWorld"", wordUtils.capitalize(""helloworld"", new char[] {}),
                ""Empty delimiters should return string capitalized at first character only"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalize with null string"")
    void testCapitalizeNullString() {
        assertNull(wordUtils.capitalize(null, new char[] {' '}),
                ""Null input string should return null"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String, char[])","java.lang.String capitalizeFully(java.lang.String, char[])","{
    char[] delimiters;
    java.lang.String str;
    unknown $stack3, $stack4, $stack5, $stack6, $stack7, delimLen;


    str := @parameter0: java.lang.String;
    delimiters := @parameter1: char[];

    if delimiters != null goto label1;
    $stack6 = -1;

    goto label2;

  label1:
    $stack6 = lengthof delimiters;

  label2:
    $stack7 = str;
    $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>($stack7);

    if $stack3 != 0 goto label3;

    if delimLen != 0 goto label4;

  label3:
    $stack5 = str;

    return $stack5;

  label4:
    str = virtualinvoke str.<java.lang.String: java.lang.String toLowerCase()>();
    $stack4 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String,char[])>(str, delimiters);

    return $stack4;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Capitalize fully using whitespace as delimiter"")
    void testCapitalizeFully_WhitespaceDelimiter() {
        String input = ""hello world"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with multiple delimiters"")
    void testCapitalizeFully_MultipleDelimiters() {
        String input = ""hello-world,test|string"";
        char[] delimiters = {'-', ',', '|'};
        assertEquals(""Hello-World,Test|String"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with no delimiters (should capitalize first letter)"")
    void testCapitalizeFully_NoDelimiters() {
        String input = ""hello"";
        char[] delimiters = {};
        assertEquals(""Hello"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with all lowercase"")
    void testCapitalizeFully_AllLowercase() {
        String input = ""multiple words here"";
        char[] delimiters = {' '};
        assertEquals(""Multiple Words Here"", wordUtils.capitalizeFully(input, delimiters));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Capitalize fully with empty string"")
    void testCapitalizeFully_EmptyString() {
        String input = """";
        char[] delimiters = {' '};
        assertEquals("""", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with null input"")
    void testCapitalizeFully_NullString() {
        String input = null;
        char[] delimiters = {' '};
        assertNull(wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with null delimiters"")
    void testCapitalizeFully_NullDelimiters() {
        String input = ""hello world"";
        char[] delimiters = null;
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with empty delimiters"")
    void testCapitalizeFully_EmptyDelimiters() {
        String input = ""hello-world"";
        char[] delimiters = {};
        assertEquals(""Hello-world"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully mixed case input"")
    void testCapitalizeFully_MixedCaseInput() {
        String input = ""HeLLo WoRLd"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with all uppercase"")
    void testCapitalizeFully_AllUppercase() {
        String input = ""HELLO WORLD"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with non-letter characters"")
    void testCapitalizeFully_NonLetterCharacters() {
        String input = ""123@world"";
        char[] delimiters = {'@'};
        assertEquals(""123@World"", wordUtils.capitalizeFully(input, delimiters));
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Capitalize fully using whitespace as delimiter"")
    void testCapitalizeFully_WhitespaceDelimiter() {
        String input = ""hello world"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with multiple delimiters"")
    void testCapitalizeFully_MultipleDelimiters() {
        String input = ""hello-world,test|string"";
        char[] delimiters = {'-', ',', '|'};
        assertEquals(""Hello-World,Test|String"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with no delimiters (should capitalize first letter)"")
    void testCapitalizeFully_NoDelimiters() {
        String input = ""hello"";
        char[] delimiters = {};
        assertEquals(""Hello"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with all lowercase"")
    void testCapitalizeFully_AllLowercase() {
        String input = ""multiple words here"";
        char[] delimiters = {' '};
        assertEquals(""Multiple Words Here"", wordUtils.capitalizeFully(input, delimiters));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Capitalize fully with empty string"")
    void testCapitalizeFully_EmptyString() {
        String input = """";
        char[] delimiters = {' '};
        assertEquals("""", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with null input"")
    void testCapitalizeFully_NullString() {
        String input = null;
        char[] delimiters = {' '};
        assertNull(wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with null delimiters"")
    void testCapitalizeFully_NullDelimiters() {
        String input = ""hello world"";
        char[] delimiters = null;
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with empty delimiters"")
    void testCapitalizeFully_EmptyDelimiters() {
        String input = ""hello-world"";
        char[] delimiters = {};
        assertEquals(""Hello-world"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully mixed case input"")
    void testCapitalizeFully_MixedCaseInput() {
        String input = ""HeLLo WoRLd"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with all uppercase"")
    void testCapitalizeFully_AllUppercase() {
        String input = ""HELLO WORLD"";
        char[] delimiters = {' '};
        assertEquals(""Hello World"", wordUtils.capitalizeFully(input, delimiters));
    }

    @Test
    @DisplayName(""Capitalize fully with non-letter characters"")
    void testCapitalizeFully_NonLetterCharacters() {
        String input = ""123@world"";
        char[] delimiters = {'@'};
        assertEquals(""123@World"", wordUtils.capitalizeFully(input, delimiters));
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String, char[])","java.lang.String uncapitalize(java.lang.String, char[])","{
    char[] delimiters;
    java.lang.String str;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack7, $stack8, $stack9, buffer, ch, delimLen, i, uncapitalizeNext;


    str := @parameter0: java.lang.String;
    delimiters := @parameter1: char[];

    if delimiters != null goto label1;
    $stack15 = -1;

    goto label2;

  label1:
    $stack15 = lengthof delimiters;

  label2:
    $stack16 = str;
    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>($stack16);

    if $stack7 != 0 goto label3;

    if delimLen != 0 goto label4;

  label3:
    $stack14 = str;

    return $stack14;

  label4:
    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    uncapitalizeNext = 1;
    i = 0;

  label5:
    $stack12 = i;
    $stack11 = buffer;
    $stack8 = lengthof $stack11;

    if $stack12 >= $stack8 goto label8;
    ch = buffer[i];
    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char,char[])>(ch, delimiters);

    if $stack10 == 0 goto label6;
    uncapitalizeNext = 1;

    goto label7;

  label6:
    if uncapitalizeNext == 0 goto label7;
    $stack13 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);
    buffer[i] = $stack13;
    uncapitalizeNext = 0;

  label7:
    i = i + 1;

    goto label5;

  label8:
    $stack9 = new java.lang.String;
    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);

    return $stack9;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Uncapitalize words with given delimiters"")
    void testUncapitalizeWithDelimiters() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World"", new char[]{' '}),
                ""Should uncapitalize each word after the delimiter"");
        assertEquals(""java-is-fun"", wordUtils.uncapitalize(""Java-Is-Fun"", new char[]{'-'}),
                ""Should uncapitalize each word after the delimiter"");
    }

    @Test
    @DisplayName(""Uncapitalize words without any delimiters"")
    void testUncapitalizeWithoutDelimiters() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World"", null),
                ""Should uncapitalize entire string when delimiters are null"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with empty string"")
    void testUncapitalizeEmptyString() {
        assertEquals("""", wordUtils.uncapitalize("""", new char[]{' '}), ""Empty string should return empty"");
        assertEquals("""", wordUtils.uncapitalize("""", null), ""Empty string with null delimiters should return empty"");
    }

    @Test
    @DisplayName(""Test single character strings"")
    void testUncapitalizeSingleCharacter() {
        assertEquals(""a"", wordUtils.uncapitalize(""A"", new char[]{' '}), ""Should uncapitalize single character string"");
        assertEquals(""b"", wordUtils.uncapitalize(""b"", null), ""Single lowercase character should stay lowercase"");
    }

    @Test
    @DisplayName(""Test strings with no uppercase letters"")
    void testUncapitalizeAlreadyUncapitalized() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""hello world"", new char[]{' '}),
                ""Should return the same string if already uncapitalized"");
    }

    // EDGE CASES (Special Characters)

    @Test
    @DisplayName(""Uncapitalize with delimiters at start and end"")
    void testDelimitersAtStartAndEnd() {
        assertEquals("" word "", wordUtils.uncapitalize("" Word "", new char[]{' '}),
                ""Should handle delimiters at the start and end"");
    }

    @Test
    @DisplayName(""Uncapitalize with consecutive delimiters"")
    void testConsecutiveDelimiters() {
        assertEquals(""a  b"", wordUtils.uncapitalize(""A  B"", new char[]{' '}),
                ""Should handle consecutive delimiters properly"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with non-letter characters"")
    void testUncapitalizeWithNonLetterCharacters() {
        assertEquals(""test123"", wordUtils.uncapitalize(""Test123"", new char[]{' '}), 
                ""Numeric characters should remain unchanged"");
        assertEquals(""word! test@function"", wordUtils.uncapitalize(""Word! Test@Function"", new char[]{' ', '@'}),
                ""Special characters should be handled correctly"");
    }

    @Test
    @DisplayName(""Uncapitalize using multiple delimiters"")
    void testUncapitalizeWithMultipleDelimiters() {
        assertEquals(""java:is.fun:test"", wordUtils.uncapitalize(""Java:is.Fun:Test"", new char[]{':', '.'}),
                ""Should handle multiple delimiters"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Null string with valid delimiters"")
    void testUncapitalizeNullString() {
        assertNull(wordUtils.uncapitalize(null, new char[]{' '}), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Null string with null delimiters"")
    void testUncapitalizeNullStringAndDelimiters() {
        assertNull(wordUtils.uncapitalize(null, null), ""Null string and delimiters should return null"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Uncapitalize words with given delimiters"")
    void testUncapitalizeWithDelimiters() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World"", new char[]{' '}),
                ""Should uncapitalize each word after the delimiter"");
        assertEquals(""java-is-fun"", wordUtils.uncapitalize(""Java-Is-Fun"", new char[]{'-'}),
                ""Should uncapitalize each word after the delimiter"");
    }

    @Test
    @DisplayName(""Uncapitalize words without any delimiters"")
    void testUncapitalizeWithoutDelimiters() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""Hello World"", null),
                ""Should uncapitalize entire string when delimiters are null"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with empty string"")
    void testUncapitalizeEmptyString() {
        assertEquals("""", wordUtils.uncapitalize("""", new char[]{' '}), ""Empty string should return empty"");
        assertEquals("""", wordUtils.uncapitalize("""", null), ""Empty string with null delimiters should return empty"");
    }

    @Test
    @DisplayName(""Test single character strings"")
    void testUncapitalizeSingleCharacter() {
        assertEquals(""a"", wordUtils.uncapitalize(""A"", new char[]{' '}), ""Should uncapitalize single character string"");
        assertEquals(""b"", wordUtils.uncapitalize(""b"", null), ""Single lowercase character should stay lowercase"");
    }

    @Test
    @DisplayName(""Test strings with no uppercase letters"")
    void testUncapitalizeAlreadyUncapitalized() {
        assertEquals(""hello world"", wordUtils.uncapitalize(""hello world"", new char[]{' '}),
                ""Should return the same string if already uncapitalized"");
    }

    // EDGE CASES (Special Characters)

    @Test
    @DisplayName(""Uncapitalize with delimiters at start and end"")
    void testDelimitersAtStartAndEnd() {
        assertEquals("" word "", wordUtils.uncapitalize("" Word "", new char[]{' '}),
                ""Should handle delimiters at the start and end"");
    }

    @Test
    @DisplayName(""Uncapitalize with consecutive delimiters"")
    void testConsecutiveDelimiters() {
        assertEquals(""a  b"", wordUtils.uncapitalize(""A  B"", new char[]{' '}),
                ""Should handle consecutive delimiters properly"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with non-letter characters"")
    void testUncapitalizeWithNonLetterCharacters() {
        assertEquals(""test123"", wordUtils.uncapitalize(""Test123"", new char[]{' '}), 
                ""Numeric characters should remain unchanged"");
        assertEquals(""word! test@function"", wordUtils.uncapitalize(""Word! Test@Function"", new char[]{' ', '@'}),
                ""Special characters should be handled correctly"");
    }

    @Test
    @DisplayName(""Uncapitalize using multiple delimiters"")
    void testUncapitalizeWithMultipleDelimiters() {
        assertEquals(""java:is.fun:test"", wordUtils.uncapitalize(""Java:is.Fun:Test"", new char[]{':', '.'}),
                ""Should handle multiple delimiters"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Null string with valid delimiters"")
    void testUncapitalizeNullString() {
        assertNull(wordUtils.uncapitalize(null, new char[]{' '}), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Null string with null delimiters"")
    void testUncapitalizeNullStringAndDelimiters() {
        assertNull(wordUtils.uncapitalize(null, null), ""Null string and delimiters should return null"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.initials(java.lang.String, char[])","java.lang.String initials(java.lang.String, char[])","{
    char[] delimiters;
    java.lang.String str;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, $stack18, $stack19, $stack20, $stack21, $stack22, $stack23, $stack24, $stack25, $stack8, $stack9, buf, ch, count, i, lastWasGap, strLen;


    str := @parameter0: java.lang.String;
    delimiters := @parameter1: char[];
    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack8 == 0 goto label1;

    return str;

  label1:
    if delimiters == null goto label2;
    $stack16 = lengthof delimiters;

    if $stack16 != 0 goto label2;

    return """";

  label2:
    $stack17 = str;
    $stack18 = virtualinvoke str.<java.lang.String: int length()>();
    $stack20 = strLen;
    $stack19 = 2;
    $stack9 = $stack20 / $stack19;
    $stack21 = 1;
    $stack10 = $stack9 + $stack21;
    $stack22 = newarray (char)[$stack10];
    $stack23 = 0;
    count = $stack23;
    $stack24 = 1;
    lastWasGap = $stack24;
    $stack25 = 0;
    i = $stack25;

  label3:
    $stack14 = i;
    $stack13 = strLen;

    if $stack14 >= $stack13 goto label6;
    ch = virtualinvoke str.<java.lang.String: char charAt(int)>(i);
    $stack12 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char,char[])>(ch, delimiters);

    if $stack12 == 0 goto label4;
    lastWasGap = 1;

    goto label5;

  label4:
    if lastWasGap == 0 goto label5;
    $stack15 = count;
    count = count + 1;
    buf[$stack15] = ch;
    lastWasGap = 0;

  label5:
    i = i + 1;

    goto label3;

  label6:
    $stack11 = new java.lang.String;
    specialinvoke $stack11.<java.lang.String: void <init>(char[],int,int)>(buf, 0, count);

    return $stack11;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test initials with delimiters"")
    void testInitialsWithDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = {' '};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD for 'John Doe'"");
    }

    @Test
    @DisplayName(""Test initials with multiple delimiters"")
    void testInitialsWithMultipleDelimiters() {
        String str = ""John.Doe-Smith"";
        char[] delimiters = {'.', '-'};
        assertEquals(""JDS"", wordUtils.initials(str, delimiters), ""Initials should be JDS for 'John.Doe-Smith'"");
    }

    @Test
    @DisplayName(""Test initials without delimiters"")
    void testInitialsWithoutDelimiters() {
        String str = ""John"";
        char[] delimiters = {' '};
        assertEquals(""J"", wordUtils.initials(str, delimiters), ""Initials should be J for 'John'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test initials for empty string"")
    void testInitialsEmptyString() {
        String str = """";
        char[] delimiters = {' '};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials of an empty string should be empty"");
    }

    @Test
    @DisplayName(""Test initials for null string with delimiters"")
    void testInitialsNullStringWithDelimiters() {
        String str = null;
        char[] delimiters = {' '};
        assertEquals(null, wordUtils.initials(str, delimiters), ""Initials of null string should be null"");
    }

    // SPECIAL DELIMITER CASE

    @Test
    @DisplayName(""Test initials when delimiters are null"")
    void testInitialsNullDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = null;
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if delimiters are null"");
    }

    @Test
    @DisplayName(""Test initials when delimiters are empty"")
    void testInitialsEmptyDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = {};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if delimiters are empty"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test initials when string starts with a delimiter"")
    void testInitialsStartingWithDelimiter() {
        String str = "".John.Doe"";
        char[] delimiters = {'.'};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD when string starts with a delimiter"");
    }

    @Test
    @DisplayName(""Test initials with consecutive delimiters"")
    void testInitialsWithConsecutiveDelimiters() {
        String str = ""John..Doe"";
        char[] delimiters = {'.'};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD for consecutive delimiters"");
    }

    @Test
    @DisplayName(""Test initials with no valid initials"")
    void testInitialsWithNoValidInitials() {
        String str = ""....."";
        char[] delimiters = {'.'};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if no valid initials"");
    }

    // SPECIAL CHARACTER CASES

    @Test
    @DisplayName(""Test initials with special character delimiters"")
    void testInitialsWithSpecialCharDelimiters() {
        String str = ""John|Doe#Smith"";
        char[] delimiters = {'|', '#'};
        assertEquals(""JDS"", wordUtils.initials(str, delimiters), ""Initials should be JDS for special character delimiters"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test initials with delimiters"")
    void testInitialsWithDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = {' '};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD for 'John Doe'"");
    }

    @Test
    @DisplayName(""Test initials with multiple delimiters"")
    void testInitialsWithMultipleDelimiters() {
        String str = ""John.Doe-Smith"";
        char[] delimiters = {'.', '-'};
        assertEquals(""JDS"", wordUtils.initials(str, delimiters), ""Initials should be JDS for 'John.Doe-Smith'"");
    }

    @Test
    @DisplayName(""Test initials without delimiters"")
    void testInitialsWithoutDelimiters() {
        String str = ""John"";
        char[] delimiters = {' '};
        assertEquals(""J"", wordUtils.initials(str, delimiters), ""Initials should be J for 'John'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test initials for empty string"")
    void testInitialsEmptyString() {
        String str = """";
        char[] delimiters = {' '};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials of an empty string should be empty"");
    }

    @Test
    @DisplayName(""Test initials for null string with delimiters"")
    void testInitialsNullStringWithDelimiters() {
        String str = null;
        char[] delimiters = {' '};
        assertEquals(null, wordUtils.initials(str, delimiters), ""Initials of null string should be null"");
    }

    // SPECIAL DELIMITER CASE

    @Test
    @DisplayName(""Test initials when delimiters are null"")
    void testInitialsNullDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = null;
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if delimiters are null"");
    }

    @Test
    @DisplayName(""Test initials when delimiters are empty"")
    void testInitialsEmptyDelimiters() {
        String str = ""John Doe"";
        char[] delimiters = {};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if delimiters are empty"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test initials when string starts with a delimiter"")
    void testInitialsStartingWithDelimiter() {
        String str = "".John.Doe"";
        char[] delimiters = {'.'};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD when string starts with a delimiter"");
    }

    @Test
    @DisplayName(""Test initials with consecutive delimiters"")
    void testInitialsWithConsecutiveDelimiters() {
        String str = ""John..Doe"";
        char[] delimiters = {'.'};
        assertEquals(""JD"", wordUtils.initials(str, delimiters), ""Initials should be JD for consecutive delimiters"");
    }

    @Test
    @DisplayName(""Test initials with no valid initials"")
    void testInitialsWithNoValidInitials() {
        String str = ""....."";
        char[] delimiters = {'.'};
        assertEquals("""", wordUtils.initials(str, delimiters), ""Initials should be empty if no valid initials"");
    }

    // SPECIAL CHARACTER CASES

    @Test
    @DisplayName(""Test initials with special character delimiters"")
    void testInitialsWithSpecialCharDelimiters() {
        String str = ""John|Doe#Smith"";
        char[] delimiters = {'|', '#'};
        assertEquals(""JDS"", wordUtils.initials(str, delimiters), ""Initials should be JDS for special character delimiters"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.initials(java.lang.String)","java.lang.String initials(java.lang.String)","{
    java.lang.String str;
    unknown $stack1;


    str := @parameter0: java.lang.String;
    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String,char[])>(str, null);

    return $stack1;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class's initials method.
 * Covers typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test initials with a typical sentence"")
    void testInitialsTypicalSentence() {
        String input = ""John Doe"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'John Doe' should be 'JD'"");
    }

    @Test
    @DisplayName(""Test initials with single word"")
    void testInitialsSingleWord() {
        String input = ""Jane"";
        String expected = ""J"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'Jane' should be 'J'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test initials with an empty string"")
    void testInitialsEmptyString() {
        String input = """";
        String expected = """";
        assertEquals(expected, wordUtils.initials(input), ""Initials of an empty string should be an empty string"");
    }

    @Test
    @DisplayName(""Test initials with all uppercase"")
    void testInitialsAllUppercase() {
        String input = ""JANE DOE"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'JANE DOE' should be 'JD'"");
    }

    @Test
    @DisplayName(""Test initials with mixed case"")
    void testInitialsMixedCase() {
        String input = ""jAnE DoE"";
        String expected = ""jD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'jAnE DoE' should be 'jD'"");
    }

    @Test
    @DisplayName(""Test initials with leading and trailing spaces"")
    void testInitialsWithSpaces() {
        String input = ""  John  Doe "";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials should ignore leading and trailing spaces"");
    }

    @Test
    @DisplayName(""Test initials with punctuation"")
    void testInitialsWithPunctuation() {
        String input = ""Jane, Doe"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'Jane, Doe' should be 'JD'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test initials with null input"")
    void testInitialsNullInput() {
        String input = null;
        assertThrows(NullPointerException.class, () -> {
            wordUtils.initials(input);
        }, ""Initials should throw NullPointerException for null input"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class's initials method.
 * Covers typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test initials with a typical sentence"")
    void testInitialsTypicalSentence() {
        String input = ""John Doe"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'John Doe' should be 'JD'"");
    }

    @Test
    @DisplayName(""Test initials with single word"")
    void testInitialsSingleWord() {
        String input = ""Jane"";
        String expected = ""J"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'Jane' should be 'J'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test initials with an empty string"")
    void testInitialsEmptyString() {
        String input = """";
        String expected = """";
        assertEquals(expected, wordUtils.initials(input), ""Initials of an empty string should be an empty string"");
    }

    @Test
    @DisplayName(""Test initials with all uppercase"")
    void testInitialsAllUppercase() {
        String input = ""JANE DOE"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'JANE DOE' should be 'JD'"");
    }

    @Test
    @DisplayName(""Test initials with mixed case"")
    void testInitialsMixedCase() {
        String input = ""jAnE DoE"";
        String expected = ""jD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'jAnE DoE' should be 'jD'"");
    }

    @Test
    @DisplayName(""Test initials with leading and trailing spaces"")
    void testInitialsWithSpaces() {
        String input = ""  John  Doe "";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials should ignore leading and trailing spaces"");
    }

    @Test
    @DisplayName(""Test initials with punctuation"")
    void testInitialsWithPunctuation() {
        String input = ""Jane, Doe"";
        String expected = ""JD"";
        assertEquals(expected, wordUtils.initials(input), ""Initials of 'Jane, Doe' should be 'JD'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test initials with null input"")
    void testInitialsNullInput() {
        String input = null;
        assertThrows(NullPointerException.class, () -> {
            wordUtils.initials(input);
        }, ""Initials should throw NullPointerException for null input"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.isDelimiter(char, char[])","boolean isDelimiter(char, char[])","{
    char ch;
    char[] delimiters;
    unknown $stack6, $stack7, $stack8, delimiter, l2, l3, l4;


    ch := @parameter0: char;
    delimiters := @parameter1: char[];

    if delimiters != null goto label1;
    $stack8 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);

    return $stack8;

  label1:
    l2 = delimiters;
    l3 = lengthof l2;
    l4 = 0;

  label2:
    $stack7 = l4;
    $stack6 = l3;

    if $stack7 >= $stack6 goto label4;
    delimiter = l2[l4];

    if ch != delimiter goto label3;

    return 1;

  label3:
    l4 = l4 + 1;

    goto label2;

  label4:
    return 0;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test when char is a delimiter"")
    void testIsDelimiterCharIsDelimiter() {
        char ch = ',';
        char[] delimiters = {',', ';', '.'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char ',' is a delimiter in {',', ';', '.'}"");
    }

    @Test
    @DisplayName(""Test when char is not a delimiter"")
    void testIsDelimiterCharIsNotDelimiter() {
        char ch = 'a';
        char[] delimiters = {',', ';', '.'};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char 'a' is not a delimiter in {',', ';', '.'}"");
    }

    @Test
    @DisplayName(""Test when char is whitespace and delimiters are null"")
    void testIsDelimiterCharIsWhitespaceDelimitersNull() {
        char ch = ' ';
        assertTrue(wordUtils.isDelimiter(ch, null), ""Whitespace char should be a delimiter when delimiters are null"");
    }

    @Test
    @DisplayName(""Test when char is not whitespace with null delimiters"")
    void testIsDelimiterCharNotWhitespaceDelimitersNull() {
        char ch = 'a';
        assertFalse(wordUtils.isDelimiter(ch, null), ""Non-whitespace char should not be a delimiter when delimiters are null"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with single-element delimiters array matching char"")
    void testIsDelimiterSingleElementMatch() {
        char ch = ';';
        char[] delimiters = {';'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char ';' should match delimiter ';'"");
    }

    @Test
    @DisplayName(""Test with single-element delimiters array not matching char"")
    void testIsDelimiterSingleElementNoMatch() {
        char ch = 'x';
        char[] delimiters = {';'};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char 'x' should not match delimiter ';'"");
    }

    @Test
    @DisplayName(""Test with empty delimiters array"")
    void testIsDelimiterEmptyDelimitersArray() {
        char ch = ',';
        char[] delimiters = {};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char ',' should not match any delimiter in empty array"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with delimiters array containing whitespace"")
    void testIsDelimiterWithWhitespaceInDelimiters() {
        char ch = ' ';
        char[] delimiters = {' ', '\t', '\n'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Whitespace char should match when it's a delimiter"");
    }

    @Test
    @DisplayName(""Test with delimiters array containing special characters"")
    void testIsDelimiterWithSpecialCharacters() {
        char ch = '$';
        char[] delimiters = {'#', '%', '$'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char '$' should match delimiter '$'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test with null char array and non-whitespace char"")
    void testIsDelimiterNullDelimitersNonWhitespaceChar() {
        char ch = 'b';
        assertFalse(wordUtils.isDelimiter(ch, null), ""Non-whitespace char should not be a delimiter with null delimiters"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test when char is a delimiter"")
    void testIsDelimiterCharIsDelimiter() {
        char ch = ',';
        char[] delimiters = {',', ';', '.'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char ',' is a delimiter in {',', ';', '.'}"");
    }

    @Test
    @DisplayName(""Test when char is not a delimiter"")
    void testIsDelimiterCharIsNotDelimiter() {
        char ch = 'a';
        char[] delimiters = {',', ';', '.'};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char 'a' is not a delimiter in {',', ';', '.'}"");
    }

    @Test
    @DisplayName(""Test when char is whitespace and delimiters are null"")
    void testIsDelimiterCharIsWhitespaceDelimitersNull() {
        char ch = ' ';
        assertTrue(wordUtils.isDelimiter(ch, null), ""Whitespace char should be a delimiter when delimiters are null"");
    }

    @Test
    @DisplayName(""Test when char is not whitespace with null delimiters"")
    void testIsDelimiterCharNotWhitespaceDelimitersNull() {
        char ch = 'a';
        assertFalse(wordUtils.isDelimiter(ch, null), ""Non-whitespace char should not be a delimiter when delimiters are null"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with single-element delimiters array matching char"")
    void testIsDelimiterSingleElementMatch() {
        char ch = ';';
        char[] delimiters = {';'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char ';' should match delimiter ';'"");
    }

    @Test
    @DisplayName(""Test with single-element delimiters array not matching char"")
    void testIsDelimiterSingleElementNoMatch() {
        char ch = 'x';
        char[] delimiters = {';'};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char 'x' should not match delimiter ';'"");
    }

    @Test
    @DisplayName(""Test with empty delimiters array"")
    void testIsDelimiterEmptyDelimitersArray() {
        char ch = ',';
        char[] delimiters = {};
        assertFalse(wordUtils.isDelimiter(ch, delimiters), ""Char ',' should not match any delimiter in empty array"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with delimiters array containing whitespace"")
    void testIsDelimiterWithWhitespaceInDelimiters() {
        char ch = ' ';
        char[] delimiters = {' ', '\t', '\n'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Whitespace char should match when it's a delimiter"");
    }

    @Test
    @DisplayName(""Test with delimiters array containing special characters"")
    void testIsDelimiterWithSpecialCharacters() {
        char ch = '$';
        char[] delimiters = {'#', '%', '$'};
        assertTrue(wordUtils.isDelimiter(ch, delimiters), ""Char '$' should match delimiter '$'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test with null char array and non-whitespace char"")
    void testIsDelimiterNullDelimitersNonWhitespaceChar() {
        char ch = 'b';
        assertFalse(wordUtils.isDelimiter(ch, null), ""Non-whitespace char should not be a delimiter with null delimiters"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int)","java.lang.String wrap(java.lang.String, int)","{
    int wrapLength;
    java.lang.String str;
    unknown $stack2;


    str := @parameter0: java.lang.String;
    wrapLength := @parameter1: int;
    $stack2 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String,int,java.lang.String,boolean)>(str, wrapLength, null, 0);

    return $stack2;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils.wrap method.
 * Covers typical cases, edge cases, corner cases, and input validation.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test wrapping a long string with spaces"")
    void testWrapLongStringWithSpaces() {
        String str = ""This is a long string that needs to be wrapped after a few words for readability."";
        int wrapLength = 20;
        String expected = ""This is a long\nstring that needs\nto be wrapped\nafter a few words\nfor readability."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should be wrapped after 20 characters"");
    }

    @Test
    @DisplayName(""Test wrapping a string with exact length of wrap"")
    void testWrapStringExactLength() {
        String str = ""This string has exact length."";
        int wrapLength = 28;
        String expected = ""This string has exact length."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should not be wrapped as it matches wrap length"");
    }

    @Test
    @DisplayName(""Test wrapping a string with new line present"")
    void testWrapStringWithNewLine() {
        String str = ""This string\nhas a new line."";
        int wrapLength = 10;
        String expected = ""This\nstring\nhas a new\nline."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should preserve existing new lines and wrap accordingly"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test wrapping an empty string"")
    void testWrapEmptyString() {
        String str = """";
        int wrapLength = 5;
        String expected = """";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""Empty string should return empty result"");
    }

    @Test
    @DisplayName(""Test wrapping a single word that exceeds the wrap length"")
    void testWrapSingleWordExceedsWrapLength() {
        String str = ""Supercalifragilisticexpialidocious"";
        int wrapLength = 10;
        String expected = ""Supercalifragilisticexpialidocious"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""A single long word should not be broken, no wrapping"");
    }

    @Test
    @DisplayName(""Test wrapping an exact single word that matches the wrap length"")
    void testWrapSingleWordMatchWrapLength() {
        String str = ""WordExactly"";
        int wrapLength = 11;
        String expected = ""WordExactly"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""Single word matching wrap length should not be broken"");
    }

    @Test
    @DisplayName(""Test wrapping with zero wrap length"")
    void testWrapWithZeroWrapLength() {
        String str = ""This is a test string."";
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, 0);
        }, ""Should throw IllegalArgumentException for zero wrapLength"");
    }

    @Test
    @DisplayName(""Test wrapping with negative wrap length"")
    void testWrapWithNegativeWrapLength() {
        String str = ""Negative wrap length test."";
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, -5);
        }, ""Should throw IllegalArgumentException for negative wrapLength"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test wrapping a string with multiple spaces"")
    void testWrapStringWithMultipleSpaces() {
        String str = ""Wrap   this  string  with   inconsistent spaces."";
        int wrapLength = 10;
        String expected = ""Wrap\nthis\nstring\nwith\ninconsistent\nspaces."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should be wrapped respecting multiple spaces"");
    }

    @Test
    @DisplayName(""Test wrapping a string with punctuation"")
    void testWrapStringWithPunctuation() {
        String str = ""This,is.a:string;with-punctuation!"";
        int wrapLength = 5;
        String expected = ""This,\nis.a:\nstring;\nwith-\npunctu\nation!"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String wrapping should handle punctuation correctly"");
    }

    @Test
    @DisplayName(""Test wrapping a null string"")
    void testWrapNullString() {
        String str = null;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, 10);
        }, ""Should throw IllegalArgumentException for null string"");
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils.wrap method.
 * Covers typical cases, edge cases, corner cases, and input validation.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test wrapping a long string with spaces"")
    void testWrapLongStringWithSpaces() {
        String str = ""This is a long string that needs to be wrapped after a few words for readability."";
        int wrapLength = 20;
        String expected = ""This is a long\nstring that needs\nto be wrapped\nafter a few words\nfor readability."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should be wrapped after 20 characters"");
    }

    @Test
    @DisplayName(""Test wrapping a string with exact length of wrap"")
    void testWrapStringExactLength() {
        String str = ""This string has exact length."";
        int wrapLength = 28;
        String expected = ""This string has exact length."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should not be wrapped as it matches wrap length"");
    }

    @Test
    @DisplayName(""Test wrapping a string with new line present"")
    void testWrapStringWithNewLine() {
        String str = ""This string\nhas a new line."";
        int wrapLength = 10;
        String expected = ""This\nstring\nhas a new\nline."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should preserve existing new lines and wrap accordingly"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test wrapping an empty string"")
    void testWrapEmptyString() {
        String str = """";
        int wrapLength = 5;
        String expected = """";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""Empty string should return empty result"");
    }

    @Test
    @DisplayName(""Test wrapping a single word that exceeds the wrap length"")
    void testWrapSingleWordExceedsWrapLength() {
        String str = ""Supercalifragilisticexpialidocious"";
        int wrapLength = 10;
        String expected = ""Supercalifragilisticexpialidocious"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""A single long word should not be broken, no wrapping"");
    }

    @Test
    @DisplayName(""Test wrapping an exact single word that matches the wrap length"")
    void testWrapSingleWordMatchWrapLength() {
        String str = ""WordExactly"";
        int wrapLength = 11;
        String expected = ""WordExactly"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""Single word matching wrap length should not be broken"");
    }

    @Test
    @DisplayName(""Test wrapping with zero wrap length"")
    void testWrapWithZeroWrapLength() {
        String str = ""This is a test string."";
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, 0);
        }, ""Should throw IllegalArgumentException for zero wrapLength"");
    }

    @Test
    @DisplayName(""Test wrapping with negative wrap length"")
    void testWrapWithNegativeWrapLength() {
        String str = ""Negative wrap length test."";
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, -5);
        }, ""Should throw IllegalArgumentException for negative wrapLength"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test wrapping a string with multiple spaces"")
    void testWrapStringWithMultipleSpaces() {
        String str = ""Wrap   this  string  with   inconsistent spaces."";
        int wrapLength = 10;
        String expected = ""Wrap\nthis\nstring\nwith\ninconsistent\nspaces."";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String should be wrapped respecting multiple spaces"");
    }

    @Test
    @DisplayName(""Test wrapping a string with punctuation"")
    void testWrapStringWithPunctuation() {
        String str = ""This,is.a:string;with-punctuation!"";
        int wrapLength = 5;
        String expected = ""This,\nis.a:\nstring;\nwith-\npunctu\nation!"";
        assertEquals(expected, wordUtils.wrap(str, wrapLength), ""String wrapping should handle punctuation correctly"");
    }

    @Test
    @DisplayName(""Test wrapping a null string"")
    void testWrapNullString() {
        String str = null;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            wordUtils.wrap(str, 10);
        }, ""Should throw IllegalArgumentException for null string"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String)","java.lang.String capitalizeFully(java.lang.String)","{
    java.lang.String str;
    unknown $stack1;


    str := @parameter0: java.lang.String;
    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String,char[])>(str, null);

    return $stack1;
}
","```java
package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class, focusing on the capitalizeFully method.
 * Includes typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalizeFully with a regular string"")
    void testCapitalizeFullyWithRegularString() {
        String input = ""hello world"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with mixed case string"")
    void testCapitalizeFullyWithMixedCaseString() {
        String input = ""hELLO wORLD"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with single word"")
    void testCapitalizeFullyWithSingleWord() {
        String input = ""java"";
        String expected = ""Java"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with already capitalized string"")
    void testCapitalizeFullyAlreadyCapitalized() {
        String input = ""Hello World"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalizeFully with empty string"")
    void testCapitalizeFullyWithEmptyString() {
        String input = """";
        String expected = """";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with string containing only spaces"")
    void testCapitalizeFullyWithSpacesOnly() {
        String input = ""   "";
        String expected = ""   "";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with string having leading and trailing spaces"")
    void testCapitalizeFullyWithLeadingTrailingSpaces() {
        String input = ""  hello world  "";
        String expected = ""  Hello World  "";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalizeFully with null input"")
    void testCapitalizeFullyWithNullInput() {
        String input = null;
        assertNull(WordUtils.capitalizeFully(input), ""capitalizeFully should return null for null input"");
    }

    @Test
    @DisplayName(""Test capitalizeFully with string containing special characters"")
    void testCapitalizeFullyWithSpecialCharacters() {
        String input = ""hello@world!"";
        String expected = ""Hello@World!"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the WordUtils class, focusing on the capitalizeFully method.
 * Includes typical cases, edge cases, and error handling.
 */
class WordUtilsTest {

    private WordUtils wordUtils;

    @BeforeEach
    void setUp() {
        wordUtils = new WordUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test capitalizeFully with a regular string"")
    void testCapitalizeFullyWithRegularString() {
        String input = ""hello world"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with mixed case string"")
    void testCapitalizeFullyWithMixedCaseString() {
        String input = ""hELLO wORLD"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with single word"")
    void testCapitalizeFullyWithSingleWord() {
        String input = ""java"";
        String expected = ""Java"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with already capitalized string"")
    void testCapitalizeFullyAlreadyCapitalized() {
        String input = ""Hello World"";
        String expected = ""Hello World"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test capitalizeFully with empty string"")
    void testCapitalizeFullyWithEmptyString() {
        String input = """";
        String expected = """";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with string containing only spaces"")
    void testCapitalizeFullyWithSpacesOnly() {
        String input = ""   "";
        String expected = ""   "";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    @Test
    @DisplayName(""Test capitalizeFully with string having leading and trailing spaces"")
    void testCapitalizeFullyWithLeadingTrailingSpaces() {
        String input = ""  hello world  "";
        String expected = ""  Hello World  "";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test capitalizeFully with null input"")
    void testCapitalizeFullyWithNullInput() {
        String input = null;
        assertNull(WordUtils.capitalizeFully(input), ""capitalizeFully should return null for null input"");
    }

    @Test
    @DisplayName(""Test capitalizeFully with string containing special characters"")
    void testCapitalizeFullyWithSpecialCharacters() {
        String input = ""hello@world!"";
        String expected = ""Hello@World!"";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/WordUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.delete(java.lang.String, java.lang.String[])","java.lang.String delete(java.lang.String, java.lang.String[])","{
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack2, $stack3, $stack4, $stack5;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];
    $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack2 != 0 goto label1;
    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);

    if $stack3 == 0 goto label2;

  label1:
    $stack5 = str;

    return $stack5;

  label2:
    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String,java.lang.String[],boolean)>(str, set, 0);

    return $stack4;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test deleting characters from a string"")
    void testDeleteChars() {
        String str = ""hello world"";
        String[] set = {""h"", ""e""};
        assertEquals(""llo world"", charSetUtils.delete(str, set), ""Should delete 'h' and 'e' from 'hello world'"");
    }

    @Test
    @DisplayName(""Test deleting characters not present in the string"")
    void testDeleteCharsNotPresent() {
        String str = ""hello world"";
        String[] set = {""x"", ""y"", ""z""};
        assertEquals(""hello world"", charSetUtils.delete(str, set), ""No changes expected if chars not present"");
    }

    @Test
    @DisplayName(""Test deleting all characters from the string"")
    void testDeleteAllChars() {
        String str = ""abc"";
        String[] set = {""a"", ""b"", ""c""};
        assertEquals("""", charSetUtils.delete(str, set), ""Should delete all characters to form an empty string"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with an empty string"")
    void testDeleteFromEmptyString() {
        String str = """";
        String[] set = {""a"", ""b""};
        assertEquals("""", charSetUtils.delete(str, set), ""Deleting from an empty string should return an empty string"");
    }

    @Test
    @DisplayName(""Test with an empty set"")
    void testDeleteWithEmptySet() {
        String str = ""test"";
        String[] set = {};
        assertEquals(""test"", charSetUtils.delete(str, set), ""Empty set should not alter the string"");
    }

    @Test
    @DisplayName(""Test null string"")
    void testDeleteNullString() {
        String str = null;
        String[] set = {""a"", ""b""};
        assertNull(charSetUtils.delete(str, set), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Test null set"")
    void testDeleteNullSet() {
        String str = ""test"";
        String[] set = null;
        assertEquals(""test"", charSetUtils.delete(str, set), ""Null set should not alter the string"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with special characters"")
    void testDeleteSpecialCharacters() {
        String str = ""hello!@#"";
        String[] set = {""!"", ""#""};
        assertEquals(""hello@"", charSetUtils.delete(str, set), ""Should remove special characters '!' and '#'"");
    }

    @Test
    @DisplayName(""Test deleting the same character multiple times"")
    void testDeleteDuplicateChars() {
        String str = ""mississippi"";
        String[] set = {""s""};
        assertEquals(""miippi"", charSetUtils.delete(str, set), ""Should delete all occurrences of 's'"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test deleting characters from a string"")
    void testDeleteChars() {
        String str = ""hello world"";
        String[] set = {""h"", ""e""};
        assertEquals(""llo world"", charSetUtils.delete(str, set), ""Should delete 'h' and 'e' from 'hello world'"");
    }

    @Test
    @DisplayName(""Test deleting characters not present in the string"")
    void testDeleteCharsNotPresent() {
        String str = ""hello world"";
        String[] set = {""x"", ""y"", ""z""};
        assertEquals(""hello world"", charSetUtils.delete(str, set), ""No changes expected if chars not present"");
    }

    @Test
    @DisplayName(""Test deleting all characters from the string"")
    void testDeleteAllChars() {
        String str = ""abc"";
        String[] set = {""a"", ""b"", ""c""};
        assertEquals("""", charSetUtils.delete(str, set), ""Should delete all characters to form an empty string"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with an empty string"")
    void testDeleteFromEmptyString() {
        String str = """";
        String[] set = {""a"", ""b""};
        assertEquals("""", charSetUtils.delete(str, set), ""Deleting from an empty string should return an empty string"");
    }

    @Test
    @DisplayName(""Test with an empty set"")
    void testDeleteWithEmptySet() {
        String str = ""test"";
        String[] set = {};
        assertEquals(""test"", charSetUtils.delete(str, set), ""Empty set should not alter the string"");
    }

    @Test
    @DisplayName(""Test null string"")
    void testDeleteNullString() {
        String str = null;
        String[] set = {""a"", ""b""};
        assertNull(charSetUtils.delete(str, set), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Test null set"")
    void testDeleteNullSet() {
        String str = ""test"";
        String[] set = null;
        assertEquals(""test"", charSetUtils.delete(str, set), ""Null set should not alter the string"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test with special characters"")
    void testDeleteSpecialCharacters() {
        String str = ""hello!@#"";
        String[] set = {""!"", ""#""};
        assertEquals(""hello@"", charSetUtils.delete(str, set), ""Should remove special characters '!' and '#'"");
    }

    @Test
    @DisplayName(""Test deleting the same character multiple times"")
    void testDeleteDuplicateChars() {
        String str = ""mississippi"";
        String[] set = {""s""};
        assertEquals(""miippi"", charSetUtils.delete(str, set), ""Should delete all occurrences of 's'"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.modify(java.lang.String, java.lang.String[], boolean)","java.lang.String modify(java.lang.String, java.lang.String[], boolean)","{
    boolean expect;
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack8, $stack9, buffer, chars, chrs, i, sz;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];
    expect := @parameter2: boolean;
    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);
    $stack8 = new java.lang.StringBuilder;
    $stack9 = virtualinvoke str.<java.lang.String: int length()>();
    specialinvoke $stack8.<java.lang.StringBuilder: void <init>(int)>($stack9);
    buffer = $stack8;
    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    sz = lengthof chrs;
    i = 0;

  label1:
    $stack14 = i;
    $stack13 = sz;

    if $stack14 >= $stack13 goto label3;
    $stack11 = chrs[i];
    $stack12 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>($stack11);

    if $stack12 != expect goto label2;
    $stack15 = chrs[i];
    $stack16 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack15);

  label2:
    i = i + 1;

    goto label1;

  label3:
    $stack10 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();

    return $stack10;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test modification with expect false and character set present"")
    void testModifyExpectFalseWithSet() {
        String result = charSetUtils.modify(""hello"", new String[]{""el""}, false);
        assertEquals(""hlo"", result, ""Should remove 'e' and 'l' from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with expect true and character set present"")
    void testModifyExpectTrueWithSet() {
        String result = charSetUtils.modify(""hello"", new String[]{""el""}, true);
        assertEquals(""el"", result, ""Should retain 'e' and 'l' from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with empty set and expect false"")
    void testModifyWithEmptySetExpectFalse() {
        String result = charSetUtils.modify(""hello"", new String[]{}, false);
        assertEquals(""hello"", result, ""Should retain all characters from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with empty set and expect true"")
    void testModifyWithEmptySetExpectTrue() {
        String result = charSetUtils.modify(""hello"", new String[]{}, true);
        assertEquals("""", result, ""Should remove all characters since set is empty"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test modification with single character string and matching set"")
    void testModifySingleCharacterMatchingSet() {
        String result = charSetUtils.modify(""a"", new String[]{""a""}, true);
        assertEquals(""a"", result, ""Should retain the single character 'a'"");
    }

    @Test
    @DisplayName(""Test modification with single character string and non-matching set"")
    void testModifySingleCharacterNonMatchingSet() {
        String result = charSetUtils.modify(""a"", new String[]{""b""}, false);
        assertEquals(""a"", result, ""Should retain the single character 'a'"");
    }

    @Test
    @DisplayName(""Test modification with entire matching set"")
    void testModifyWithEntireMatchingSet() {
        String result = charSetUtils.modify(""abc"", new String[]{""abc""}, true);
        assertEquals(""abc"", result, ""Should retain all characters since all match the set"");
    }

    @Test
    @DisplayName(""Test modification removing all characters"")
    void testModifyRemovingAllCharacters() {
        String result = charSetUtils.modify(""abc"", new String[]{""abc""}, false);
        assertEquals("""", result, ""Should remove all characters from 'abc'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test modification with null string"")
    void testModifyWithNullString() {
        assertThrows(NullPointerException.class, () -> charSetUtils.modify(null, new String[]{""a""}, false),
                ""Should throw NullPointerException for null string"");
    }

    @Test
    @DisplayName(""Test modification with null set"")
    void testModifyWithNullSet() {
        String result = charSetUtils.modify(""hello"", null, false);
        assertEquals(""hello"", result, ""Should retain all characters when set is null"");
    }

    @Test
    @DisplayName(""Test modification with empty string"")
    void testModifyWithEmptyString() {
        String result = charSetUtils.modify("""", new String[]{""a""}, false);
        assertEquals("""", result, ""Should return an empty string when input is empty"");
    }

    @Test
    @DisplayName(""Test modification with duplicate characters in set"")
    void testModifyWithDuplicateCharactersInSet() {
        String result = charSetUtils.modify(""banana"", new String[]{""ana""}, true);
        assertEquals(""anana"", result, ""Should retain all 'a' and 'n'"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test modification with expect false and character set present"")
    void testModifyExpectFalseWithSet() {
        String result = charSetUtils.modify(""hello"", new String[]{""el""}, false);
        assertEquals(""hlo"", result, ""Should remove 'e' and 'l' from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with expect true and character set present"")
    void testModifyExpectTrueWithSet() {
        String result = charSetUtils.modify(""hello"", new String[]{""el""}, true);
        assertEquals(""el"", result, ""Should retain 'e' and 'l' from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with empty set and expect false"")
    void testModifyWithEmptySetExpectFalse() {
        String result = charSetUtils.modify(""hello"", new String[]{}, false);
        assertEquals(""hello"", result, ""Should retain all characters from 'hello'"");
    }

    @Test
    @DisplayName(""Test modification with empty set and expect true"")
    void testModifyWithEmptySetExpectTrue() {
        String result = charSetUtils.modify(""hello"", new String[]{}, true);
        assertEquals("""", result, ""Should remove all characters since set is empty"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test modification with single character string and matching set"")
    void testModifySingleCharacterMatchingSet() {
        String result = charSetUtils.modify(""a"", new String[]{""a""}, true);
        assertEquals(""a"", result, ""Should retain the single character 'a'"");
    }

    @Test
    @DisplayName(""Test modification with single character string and non-matching set"")
    void testModifySingleCharacterNonMatchingSet() {
        String result = charSetUtils.modify(""a"", new String[]{""b""}, false);
        assertEquals(""a"", result, ""Should retain the single character 'a'"");
    }

    @Test
    @DisplayName(""Test modification with entire matching set"")
    void testModifyWithEntireMatchingSet() {
        String result = charSetUtils.modify(""abc"", new String[]{""abc""}, true);
        assertEquals(""abc"", result, ""Should retain all characters since all match the set"");
    }

    @Test
    @DisplayName(""Test modification removing all characters"")
    void testModifyRemovingAllCharacters() {
        String result = charSetUtils.modify(""abc"", new String[]{""abc""}, false);
        assertEquals("""", result, ""Should remove all characters from 'abc'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test modification with null string"")
    void testModifyWithNullString() {
        assertThrows(NullPointerException.class, () -> charSetUtils.modify(null, new String[]{""a""}, false),
                ""Should throw NullPointerException for null string"");
    }

    @Test
    @DisplayName(""Test modification with null set"")
    void testModifyWithNullSet() {
        String result = charSetUtils.modify(""hello"", null, false);
        assertEquals(""hello"", result, ""Should retain all characters when set is null"");
    }

    @Test
    @DisplayName(""Test modification with empty string"")
    void testModifyWithEmptyString() {
        String result = charSetUtils.modify("""", new String[]{""a""}, false);
        assertEquals("""", result, ""Should return an empty string when input is empty"");
    }

    @Test
    @DisplayName(""Test modification with duplicate characters in set"")
    void testModifyWithDuplicateCharactersInSet() {
        String result = charSetUtils.modify(""banana"", new String[]{""ana""}, true);
        assertEquals(""anana"", result, ""Should retain all 'a' and 'n'"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.keep(java.lang.String, java.lang.String[])","java.lang.String keep(java.lang.String, java.lang.String[])","{
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack2, $stack3, $stack4, $stack5;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];

    if str != null goto label1;

    return null;

  label1:
    $stack2 = virtualinvoke str.<java.lang.String: boolean isEmpty()>();

    if $stack2 != 0 goto label2;
    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);

    if $stack3 == 0 goto label3;

  label2:
    $stack5 = """";

    return $stack5;

  label3:
    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String,java.lang.String[],boolean)>(str, set, 1);

    return $stack4;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test keeping characters present in the set"")
    void testKeepCharactersPresentInSet() {
        String str = ""hello world"";
        String[] set = {""he"", ""o""};
        assertEquals(""heo"", charSetUtils.keep(str, set), ""Should keep characters 'h', 'e', 'o'"");
    }

    @Test
    @DisplayName(""Test keeping characters with multiple non-overlapping sets"")
    void testKeepWithMultipleSets() {
        String str = ""abcdef"";
        String[] set = {""ab"", ""cde""};
        assertEquals(""abcde"", charSetUtils.keep(str, set), ""Should keep characters 'a', 'b', 'c', 'd', 'e'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test keeping when string is null"")
    void testKeepStringIsNull() {
        String str = null;
        String[] set = {""he""};
        assertNull(charSetUtils.keep(str, set), ""Should return null when string is null"");
    }

    @Test
    @DisplayName(""Test keeping when string is empty"")
    void testKeepStringIsEmpty() {
        String str = """";
        String[] set = {""he""};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when string is empty"");
    }

    @Test
    @DisplayName(""Test keeping when set array is empty"")
    void testKeepSetIsEmpty() {
        String str = ""hello"";
        String[] set = {};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when set array is empty"");
    }

    @Test
    @DisplayName(""Test keeping when string and set array both are empty"")
    void testKeepStringAndSetAreEmpty() {
        String str = """";
        String[] set = {};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when string and set both are empty"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test keeping when string contains all characters in set"")
    void testKeepAllCharactersInSet() {
        String str = ""abcdef"";
        String[] set = {""abcdef""};
        assertEquals(""abcdef"", charSetUtils.keep(str, set), ""Should return entire string as all characters are in set"");
    }

    @Test
    @DisplayName(""Test keeping when set has duplicate characters"")
    void testKeepDuplicateCharactersInSet() {
        String str = ""banana"";
        String[] set = {""aan""};
        assertEquals(""aana"", charSetUtils.keep(str, set), ""Should return 'aana' when set has duplicates"");
    }

    @Test
    @DisplayName(""Test keeping when set has similar looking characters"")
    void testKeepSimilarLookingCharacters() {
        String str = ""àáâãäå"";
        String[] set = {""a""};
        assertEquals(""a"", charSetUtils.keep(str, set), ""Should keep no characters when set has similar looking characters"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test keeping characters present in the set"")
    void testKeepCharactersPresentInSet() {
        String str = ""hello world"";
        String[] set = {""he"", ""o""};
        assertEquals(""heo"", charSetUtils.keep(str, set), ""Should keep characters 'h', 'e', 'o'"");
    }

    @Test
    @DisplayName(""Test keeping characters with multiple non-overlapping sets"")
    void testKeepWithMultipleSets() {
        String str = ""abcdef"";
        String[] set = {""ab"", ""cde""};
        assertEquals(""abcde"", charSetUtils.keep(str, set), ""Should keep characters 'a', 'b', 'c', 'd', 'e'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test keeping when string is null"")
    void testKeepStringIsNull() {
        String str = null;
        String[] set = {""he""};
        assertNull(charSetUtils.keep(str, set), ""Should return null when string is null"");
    }

    @Test
    @DisplayName(""Test keeping when string is empty"")
    void testKeepStringIsEmpty() {
        String str = """";
        String[] set = {""he""};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when string is empty"");
    }

    @Test
    @DisplayName(""Test keeping when set array is empty"")
    void testKeepSetIsEmpty() {
        String str = ""hello"";
        String[] set = {};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when set array is empty"");
    }

    @Test
    @DisplayName(""Test keeping when string and set array both are empty"")
    void testKeepStringAndSetAreEmpty() {
        String str = """";
        String[] set = {};
        assertEquals("""", charSetUtils.keep(str, set), ""Should return empty when string and set both are empty"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test keeping when string contains all characters in set"")
    void testKeepAllCharactersInSet() {
        String str = ""abcdef"";
        String[] set = {""abcdef""};
        assertEquals(""abcdef"", charSetUtils.keep(str, set), ""Should return entire string as all characters are in set"");
    }

    @Test
    @DisplayName(""Test keeping when set has duplicate characters"")
    void testKeepDuplicateCharactersInSet() {
        String str = ""banana"";
        String[] set = {""aan""};
        assertEquals(""aana"", charSetUtils.keep(str, set), ""Should return 'aana' when set has duplicates"");
    }

    @Test
    @DisplayName(""Test keeping when set has similar looking characters"")
    void testKeepSimilarLookingCharacters() {
        String str = ""àáâãäå"";
        String[] set = {""a""};
        assertEquals(""a"", charSetUtils.keep(str, set), ""Should keep no characters when set has similar looking characters"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.deepEmpty(java.lang.String[])","boolean deepEmpty(java.lang.String[])","{
    java.lang.String[] strings;
    unknown $stack5, $stack6, $stack7, $stack8, l1, l2, l3, s;


    strings := @parameter0: java.lang.String[];

    if strings == null goto label3;
    l1 = strings;
    l2 = lengthof l1;
    l3 = 0;

  label1:
    $stack8 = l3;
    $stack7 = l2;

    if $stack8 >= $stack7 goto label3;
    s = l1[l3];
    $stack6 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);

    if $stack6 == 0 goto label2;

    return 0;

  label2:
    l3 = l3 + 1;

    goto label1;

  label3:
    $stack5 = 1;

    return $stack5;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // COMMON CASES

    @Test
    @DisplayName(""Test deepEmpty with all empty strings"")
    void testDeepEmptyAllEmpty() {
        String[] strings = {"""", """", """"};
        assertTrue(charSetUtils.deepEmpty(strings), ""All empty strings should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with some non-empty strings"")
    void testDeepEmptyWithNonEmpty() {
        String[] strings = {"""", ""non-empty"", """"};
        assertFalse(charSetUtils.deepEmpty(strings), ""Presence of non-empty string should return false"");
    }

    @Test
    @DisplayName(""Test deepEmpty with all non-empty strings"")
    void testDeepEmptyAllNonEmpty() {
        String[] strings = {""a"", ""b"", ""c""};
        assertFalse(charSetUtils.deepEmpty(strings), ""All non-empty strings should return false"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test deepEmpty with single empty string"")
    void testDeepEmptySingleEmpty() {
        String[] strings = {""""};
        assertTrue(charSetUtils.deepEmpty(strings), ""Single empty string should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with single non-empty string"")
    void testDeepEmptySingleNonEmpty() {
        String[] strings = {""non-empty""};
        assertFalse(charSetUtils.deepEmpty(strings), ""Single non-empty string should return false"");
    }

    @Test
    @DisplayName(""Test deepEmpty with empty array"")
    void testDeepEmptyEmptyArray() {
        String[] strings = {};
        assertTrue(charSetUtils.deepEmpty(strings), ""Empty array should return true"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test deepEmpty with null array"")
    void testDeepEmptyNullArray() {
        String[] strings = null;
        assertTrue(charSetUtils.deepEmpty(strings), ""Null array should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with null elements"")
    void testDeepEmptyWithNullElements() {
        String[] strings = {null, null, null};
        assertTrue(charSetUtils.deepEmpty(strings), ""Array with all nulls should return true"");

        String[] mixedStrings = {"""", null, "" ""};
        assertFalse(charSetUtils.deepEmpty(mixedStrings), ""Array with non-empty/nulls should return false"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // COMMON CASES

    @Test
    @DisplayName(""Test deepEmpty with all empty strings"")
    void testDeepEmptyAllEmpty() {
        String[] strings = {"""", """", """"};
        assertTrue(charSetUtils.deepEmpty(strings), ""All empty strings should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with some non-empty strings"")
    void testDeepEmptyWithNonEmpty() {
        String[] strings = {"""", ""non-empty"", """"};
        assertFalse(charSetUtils.deepEmpty(strings), ""Presence of non-empty string should return false"");
    }

    @Test
    @DisplayName(""Test deepEmpty with all non-empty strings"")
    void testDeepEmptyAllNonEmpty() {
        String[] strings = {""a"", ""b"", ""c""};
        assertFalse(charSetUtils.deepEmpty(strings), ""All non-empty strings should return false"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test deepEmpty with single empty string"")
    void testDeepEmptySingleEmpty() {
        String[] strings = {""""};
        assertTrue(charSetUtils.deepEmpty(strings), ""Single empty string should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with single non-empty string"")
    void testDeepEmptySingleNonEmpty() {
        String[] strings = {""non-empty""};
        assertFalse(charSetUtils.deepEmpty(strings), ""Single non-empty string should return false"");
    }

    @Test
    @DisplayName(""Test deepEmpty with empty array"")
    void testDeepEmptyEmptyArray() {
        String[] strings = {};
        assertTrue(charSetUtils.deepEmpty(strings), ""Empty array should return true"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test deepEmpty with null array"")
    void testDeepEmptyNullArray() {
        String[] strings = null;
        assertTrue(charSetUtils.deepEmpty(strings), ""Null array should return true"");
    }

    @Test
    @DisplayName(""Test deepEmpty with null elements"")
    void testDeepEmptyWithNullElements() {
        String[] strings = {null, null, null};
        assertTrue(charSetUtils.deepEmpty(strings), ""Array with all nulls should return true"");

        String[] mixedStrings = {"""", null, "" ""};
        assertFalse(charSetUtils.deepEmpty(mixedStrings), ""Array with non-empty/nulls should return false"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.squeeze(java.lang.String, java.lang.String[])","java.lang.String squeeze(java.lang.String, java.lang.String[])","{
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, $stack18, $stack19, $stack20, $stack21, $stack9, buffer, ch, chars, chrs, i, lastChar, sz;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];
    $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack9 != 0 goto label1;
    $stack10 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);

    if $stack10 == 0 goto label2;

  label1:
    $stack21 = str;

    return $stack21;

  label2:
    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);
    $stack11 = new java.lang.StringBuilder;
    $stack12 = virtualinvoke str.<java.lang.String: int length()>();
    specialinvoke $stack11.<java.lang.StringBuilder: void <init>(int)>($stack12);
    buffer = $stack11;
    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    sz = lengthof chrs;
    lastChar = 32;
    ch = 32;
    i = 0;

  label3:
    $stack16 = i;
    $stack15 = sz;

    if $stack16 >= $stack15 goto label6;
    ch = chrs[i];

    if ch != lastChar goto label4;

    if i == 0 goto label4;
    $stack20 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(ch);

    if $stack20 == 0 goto label4;

    goto label5;

  label4:
    $stack18 = buffer;
    $stack17 = ch;
    $stack14 = virtualinvoke $stack18.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack17);
    $stack19 = ch;
    lastChar = $stack19;

  label5:
    i = i + 1;

    goto label3;

  label6:
    $stack13 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();

    return $stack13;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test squeeze with no repetitions"")
    void testSqueezeNoRepetitions() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", new String[]{""a"", ""b"", ""c""}), ""String should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with repetitions in the charset"")
    void testSqueezeWithRepetitions() {
        assertEquals(""abab"", charSetUtils.squeeze(""aabbab"", new String[]{""a"", ""b""}), ""Consecutive duplicates should be removed"");
    }

    @Test
    @DisplayName(""Test squeeze with all characters squeezed"")
    void testSqueezeAllCharacters() {
        assertEquals(""a"", charSetUtils.squeeze(""aaaa"", new String[]{""a""}), ""All consecutive 'a's should be reduced to one"");
    }

    @Test
    @DisplayName(""Test squeeze with mixed character sets"")
    void testSqueezeMixedCharacters() {
        assertEquals(""abc"", charSetUtils.squeeze(""aabbcc"", new String[]{""a"", ""b""}), ""Only 'a' and 'b' should be squeezed, 'c' should remain duplicated"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test squeeze with single character string"")
    void testSqueezeSingleCharacter() {
        assertEquals(""a"", charSetUtils.squeeze(""a"", new String[]{""a""}), ""Single character should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with empty string"")
    void testSqueezeEmptyString() {
        assertEquals("""", charSetUtils.squeeze("""", new String[]{""a"", ""b""}), ""Empty string should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with empty charset"")
    void testSqueezeEmptyCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", new String[]{}), ""String should remain unchanged with empty charset"");
    }

    @Test
    @DisplayName(""Test squeeze with null charset"")
    void testSqueezeNullCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", null), ""String should remain unchanged with null charset"");
    }

    @Test
    @DisplayName(""Test squeeze with null string"")
    void testSqueezeNullString() {
        assertNull(charSetUtils.squeeze(null, new String[]{""a"", ""b""}), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Test squeeze with no charset"")
    void testSqueezeNoCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", (String[]) null), ""String should remain unchanged if charset is null"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test squeeze with consecutive same characters not in set"")
    void testSqueezeConsecutiveNotInSet() {
        assertEquals(""aabbcc"", charSetUtils.squeeze(""aabbcc"", new String[]{""d"", ""e""}), ""Should remain unchanged with no shared characters"");
    }

    @Test
    @DisplayName(""Test squeeze with null and empty string"")
    void testSqueezeNullAndEmpty() {
        assertEquals("""", charSetUtils.squeeze("""", null), ""Empty string should remain unchanged even with null charset"");
    }

    @Test
    @DisplayName(""Test squeeze reducing complex repetition patterns"")
    void testSqueezeComplexPatterns() {
        assertEquals(""abcdefgh"", charSetUtils.squeeze(""aaabbbcccddeefgh"", new String[]{""a"", ""b"", ""c""}), ""Complex repetition patterns should be reduced properly"");
    }

    @Test
    @DisplayName(""Test squeeze with spaces in string"")
    void testSqueezeWithSpaces() {
        assertEquals("" a b "", charSetUtils.squeeze(""  a  b  "", new String[]{"" ""}), ""Spaces should be squeezed to single spaces"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test squeeze with no repetitions"")
    void testSqueezeNoRepetitions() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", new String[]{""a"", ""b"", ""c""}), ""String should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with repetitions in the charset"")
    void testSqueezeWithRepetitions() {
        assertEquals(""abab"", charSetUtils.squeeze(""aabbab"", new String[]{""a"", ""b""}), ""Consecutive duplicates should be removed"");
    }

    @Test
    @DisplayName(""Test squeeze with all characters squeezed"")
    void testSqueezeAllCharacters() {
        assertEquals(""a"", charSetUtils.squeeze(""aaaa"", new String[]{""a""}), ""All consecutive 'a's should be reduced to one"");
    }

    @Test
    @DisplayName(""Test squeeze with mixed character sets"")
    void testSqueezeMixedCharacters() {
        assertEquals(""abc"", charSetUtils.squeeze(""aabbcc"", new String[]{""a"", ""b""}), ""Only 'a' and 'b' should be squeezed, 'c' should remain duplicated"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test squeeze with single character string"")
    void testSqueezeSingleCharacter() {
        assertEquals(""a"", charSetUtils.squeeze(""a"", new String[]{""a""}), ""Single character should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with empty string"")
    void testSqueezeEmptyString() {
        assertEquals("""", charSetUtils.squeeze("""", new String[]{""a"", ""b""}), ""Empty string should remain unchanged"");
    }

    @Test
    @DisplayName(""Test squeeze with empty charset"")
    void testSqueezeEmptyCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", new String[]{}), ""String should remain unchanged with empty charset"");
    }

    @Test
    @DisplayName(""Test squeeze with null charset"")
    void testSqueezeNullCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", null), ""String should remain unchanged with null charset"");
    }

    @Test
    @DisplayName(""Test squeeze with null string"")
    void testSqueezeNullString() {
        assertNull(charSetUtils.squeeze(null, new String[]{""a"", ""b""}), ""Null string should return null"");
    }

    @Test
    @DisplayName(""Test squeeze with no charset"")
    void testSqueezeNoCharset() {
        assertEquals(""abc"", charSetUtils.squeeze(""abc"", (String[]) null), ""String should remain unchanged if charset is null"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test squeeze with consecutive same characters not in set"")
    void testSqueezeConsecutiveNotInSet() {
        assertEquals(""aabbcc"", charSetUtils.squeeze(""aabbcc"", new String[]{""d"", ""e""}), ""Should remain unchanged with no shared characters"");
    }

    @Test
    @DisplayName(""Test squeeze with null and empty string"")
    void testSqueezeNullAndEmpty() {
        assertEquals("""", charSetUtils.squeeze("""", null), ""Empty string should remain unchanged even with null charset"");
    }

    @Test
    @DisplayName(""Test squeeze reducing complex repetition patterns"")
    void testSqueezeComplexPatterns() {
        assertEquals(""abcdefgh"", charSetUtils.squeeze(""aaabbbcccddeefgh"", new String[]{""a"", ""b"", ""c""}), ""Complex repetition patterns should be reduced properly"");
    }

    @Test
    @DisplayName(""Test squeeze with spaces in string"")
    void testSqueezeWithSpaces() {
        assertEquals("" a b "", charSetUtils.squeeze(""  a  b  "", new String[]{"" ""}), ""Spaces should be squeezed to single spaces"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.containsAny(java.lang.String, java.lang.String[])","boolean containsAny(java.lang.String, java.lang.String[])","{
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack10, $stack11, $stack12, $stack7, $stack8, $stack9, c, chars, l3, l4, l5;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];
    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack7 != 0 goto label1;
    $stack8 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);

    if $stack8 == 0 goto label2;

  label1:
    $stack12 = 0;

    return $stack12;

  label2:
    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);
    l3 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    l4 = lengthof l3;
    l5 = 0;

  label3:
    $stack11 = l5;
    $stack10 = l4;

    if $stack11 >= $stack10 goto label5;
    c = l3[l5];
    $stack9 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);

    if $stack9 == 0 goto label4;

    return 1;

  label4:
    l5 = l5 + 1;

    goto label3;

  label5:
    return 0;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, and error handling for the `containsAny` method.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test contains any with common characters"")
    void testContainsAnyCommonCharacters() {
        assertTrue(CharSetUtils.containsAny(""abc"", new String[]{""a"", ""xyz""}), ""Should contain common character 'a'"");
        assertFalse(CharSetUtils.containsAny(""def"", new String[]{""x"", ""y"", ""z""}), ""Should not contain any common character"");
    }

    @Test
    @DisplayName(""Test contains any with all matching characters"")
    void testContainsAnyAllMatching() {
        assertTrue(CharSetUtils.containsAny(""abc"", new String[]{""a"", ""b"", ""c""}), ""All characters should match"");
    }

    @Test
    @DisplayName(""Test contains any with non-matching characters"")
    void testContainsAnyNoMatchingCharacters() {
        assertFalse(CharSetUtils.containsAny(""ghi"", new String[]{""a"", ""b"", ""c""}), ""Should not contain any matching characters"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test contains any with single character strings"")
    void testContainsAnySingleCharacterStrings() {
        assertTrue(CharSetUtils.containsAny(""a"", new String[]{""a""}), ""Single character string that matches"");
        assertFalse(CharSetUtils.containsAny(""b"", new String[]{""a""}), ""Single character string that does not match"");
    }

    @Test
    @DisplayName(""Test contains any with an empty string and non-empty set"")
    void testContainsAnyEmptyString() {
        assertFalse(CharSetUtils.containsAny("""", new String[]{""a"", ""b"", ""c""}), ""Empty string should return false"");
    }

    @Test
    @DisplayName(""Test contains any with a string and empty set"")
    void testContainsAnyEmptySet() {
        assertFalse(CharSetUtils.containsAny(""abc"", new String[]{}), ""Non-empty string with empty set should return false"");
    }

    @Test
    @DisplayName(""Test contains any with both empty string and set"")
    void testContainsAnyEmptyStringAndSet() {
        assertFalse(CharSetUtils.containsAny("""", new String[]{""""}), ""Both string and set empty should return false"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test contains any with special characters"")
    void testContainsAnySpecialCharacters() {
        assertTrue(CharSetUtils.containsAny(""a!c"", new String[]{""!"", ""?"", ""#""}), ""Should contain special character '!'"");
        assertFalse(CharSetUtils.containsAny(""abc"", new String[]{""@"", ""#"", ""%""}), ""Should not contain any special characters"");
    }

    @Test
    @DisplayName(""Test contains any with overlapping sets"")
    void testContainsAnyOverlappingSets() {
        assertTrue(CharSetUtils.containsAny(""abcdef"", new String[]{""b"", ""c"", ""x""}), ""Overlapping set with the matching character 'b'"");
    }

    // ERROR CASES (INVALID INPUT)

    @Test
    @DisplayName(""Test contains any with null string"")
    void testContainsAnyNullString() {
        assertFalse(CharSetUtils.containsAny(null, new String[]{""a"", ""b"", ""c""}), ""Null string should return false"");
    }

    @Test
    @DisplayName(""Test contains any with null set"")
    void testContainsAnyNullSet() {
        assertFalse(CharSetUtils.containsAny(""abc"", null), ""Null set should return false"");
    }

    @Test
    @DisplayName(""Test contains any with null string and set"")
    void testContainsAnyNullStringAndSet() {
        assertFalse(CharSetUtils.containsAny(null, null), ""Both string and set null should return false"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, and error handling for the `containsAny` method.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test contains any with common characters"")
    void testContainsAnyCommonCharacters() {
        assertTrue(CharSetUtils.containsAny(""abc"", new String[]{""a"", ""xyz""}), ""Should contain common character 'a'"");
        assertFalse(CharSetUtils.containsAny(""def"", new String[]{""x"", ""y"", ""z""}), ""Should not contain any common character"");
    }

    @Test
    @DisplayName(""Test contains any with all matching characters"")
    void testContainsAnyAllMatching() {
        assertTrue(CharSetUtils.containsAny(""abc"", new String[]{""a"", ""b"", ""c""}), ""All characters should match"");
    }

    @Test
    @DisplayName(""Test contains any with non-matching characters"")
    void testContainsAnyNoMatchingCharacters() {
        assertFalse(CharSetUtils.containsAny(""ghi"", new String[]{""a"", ""b"", ""c""}), ""Should not contain any matching characters"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test contains any with single character strings"")
    void testContainsAnySingleCharacterStrings() {
        assertTrue(CharSetUtils.containsAny(""a"", new String[]{""a""}), ""Single character string that matches"");
        assertFalse(CharSetUtils.containsAny(""b"", new String[]{""a""}), ""Single character string that does not match"");
    }

    @Test
    @DisplayName(""Test contains any with an empty string and non-empty set"")
    void testContainsAnyEmptyString() {
        assertFalse(CharSetUtils.containsAny("""", new String[]{""a"", ""b"", ""c""}), ""Empty string should return false"");
    }

    @Test
    @DisplayName(""Test contains any with a string and empty set"")
    void testContainsAnyEmptySet() {
        assertFalse(CharSetUtils.containsAny(""abc"", new String[]{}), ""Non-empty string with empty set should return false"");
    }

    @Test
    @DisplayName(""Test contains any with both empty string and set"")
    void testContainsAnyEmptyStringAndSet() {
        assertFalse(CharSetUtils.containsAny("""", new String[]{""""}), ""Both string and set empty should return false"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test contains any with special characters"")
    void testContainsAnySpecialCharacters() {
        assertTrue(CharSetUtils.containsAny(""a!c"", new String[]{""!"", ""?"", ""#""}), ""Should contain special character '!'"");
        assertFalse(CharSetUtils.containsAny(""abc"", new String[]{""@"", ""#"", ""%""}), ""Should not contain any special characters"");
    }

    @Test
    @DisplayName(""Test contains any with overlapping sets"")
    void testContainsAnyOverlappingSets() {
        assertTrue(CharSetUtils.containsAny(""abcdef"", new String[]{""b"", ""c"", ""x""}), ""Overlapping set with the matching character 'b'"");
    }

    // ERROR CASES (INVALID INPUT)

    @Test
    @DisplayName(""Test contains any with null string"")
    void testContainsAnyNullString() {
        assertFalse(CharSetUtils.containsAny(null, new String[]{""a"", ""b"", ""c""}), ""Null string should return false"");
    }

    @Test
    @DisplayName(""Test contains any with null set"")
    void testContainsAnyNullSet() {
        assertFalse(CharSetUtils.containsAny(""abc"", null), ""Null set should return false"");
    }

    @Test
    @DisplayName(""Test contains any with null string and set"")
    void testContainsAnyNullStringAndSet() {
        assertFalse(CharSetUtils.containsAny(null, null), ""Both string and set null should return false"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharSetUtils.count(java.lang.String, java.lang.String[])","int count(java.lang.String, java.lang.String[])","{
    java.lang.String str;
    java.lang.String[] set;
    unknown $stack10, $stack11, $stack12, $stack13, $stack8, $stack9, c, chars, count, l4, l5, l6;


    str := @parameter0: java.lang.String;
    set := @parameter1: java.lang.String[];
    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);

    if $stack8 != 0 goto label1;
    $stack9 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);

    if $stack9 == 0 goto label2;

  label1:
    $stack13 = 0;

    return $stack13;

  label2:
    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);
    count = 0;
    l4 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();
    l5 = lengthof l4;
    l6 = 0;

  label3:
    $stack12 = l6;
    $stack11 = l5;

    if $stack12 >= $stack11 goto label5;
    c = l4[l6];
    $stack10 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);

    if $stack10 == 0 goto label4;
    count = count + 1;

  label4:
    l6 = l6 + 1;

    goto label3;

  label5:
    return count;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test counting chars in a standard case"")
    void testCountCharsStandardCase() {
        String str = ""hello"";
        String[] set = {""l"", ""o""};
        assertEquals(3, charSetUtils.count(str, set), ""Count should be 3 for \""hello\"" and set {\""l\"", \""o\""}"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with empty string"")
    void testCountEmptyString() {
        String str = """";
        String[] set = {""l"", ""o""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty string"");
    }

    @Test
    @DisplayName(""Test with null string"")
    void testCountNullString() {
        String str = null;
        String[] set = {""l"", ""o""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for a null string"");
    }

    @Test
    @DisplayName(""Test with empty set"")
    void testCountEmptySet() {
        String str = ""hello"";
        String[] set = {};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty set"");
    }

    @Test
    @DisplayName(""Test with null set"")
    void testCountNullSet() {
        String str = ""hello"";
        String[] set = null;
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for a null set"");
    }

    @Test
    @DisplayName(""Test with both empty string and set"")
    void testCountBothEmptyStringAndSet() {
        String str = """";
        String[] set = {};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for both empty string and set"");
    }

    @Test
    @DisplayName(""Test with both null string and set"")
    void testCountBothNullStringAndSet() {
        String str = null;
        String[] set = null;
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for both null string and set"");
    }

    // --- Corner Cases ---

    @Test
    @DisplayName(""Test with set containing empty strings"")
    void testCountSetWithEmptyStrings() {
        String str = ""hello"";
        String[] set = {"""", """"};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty string set"");
    }
    
    @Test
    @DisplayName(""Test with set having overlapping characters"")
    void testCountSetWithOverlappingChars() {
        String str = ""hello"";
        String[] set = {""he"", ""ll""};
        assertEquals(5, charSetUtils.count(str, set), ""Count should be 5 for overlapping set elements"");
    }

    // --- Custom Cases ---

    @Test
    @DisplayName(""Test with unique characters"")
    void testCountUniqueCharacters() {
        String str = ""abcdefg"";
        String[] set = {""a"", ""b"", ""c""};
        assertEquals(3, charSetUtils.count(str, set), ""Count should be 3 for unique characters in set"");
    }

    @Test
    @DisplayName(""Test with no matching characters"")
    void testCountNoMatchingCharacters() {
        String str = ""hello"";
        String[] set = {""x"", ""y"", ""z""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 when no characters match"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharSetUtils class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharSetUtilsTest {

    private CharSetUtils charSetUtils;

    @BeforeEach
    void setUp() {
        charSetUtils = new CharSetUtils();
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test counting chars in a standard case"")
    void testCountCharsStandardCase() {
        String str = ""hello"";
        String[] set = {""l"", ""o""};
        assertEquals(3, charSetUtils.count(str, set), ""Count should be 3 for \""hello\"" and set {\""l\"", \""o\""}"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test with empty string"")
    void testCountEmptyString() {
        String str = """";
        String[] set = {""l"", ""o""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty string"");
    }

    @Test
    @DisplayName(""Test with null string"")
    void testCountNullString() {
        String str = null;
        String[] set = {""l"", ""o""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for a null string"");
    }

    @Test
    @DisplayName(""Test with empty set"")
    void testCountEmptySet() {
        String str = ""hello"";
        String[] set = {};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty set"");
    }

    @Test
    @DisplayName(""Test with null set"")
    void testCountNullSet() {
        String str = ""hello"";
        String[] set = null;
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for a null set"");
    }

    @Test
    @DisplayName(""Test with both empty string and set"")
    void testCountBothEmptyStringAndSet() {
        String str = """";
        String[] set = {};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for both empty string and set"");
    }

    @Test
    @DisplayName(""Test with both null string and set"")
    void testCountBothNullStringAndSet() {
        String str = null;
        String[] set = null;
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for both null string and set"");
    }

    // --- Corner Cases ---

    @Test
    @DisplayName(""Test with set containing empty strings"")
    void testCountSetWithEmptyStrings() {
        String str = ""hello"";
        String[] set = {"""", """"};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 for an empty string set"");
    }
    
    @Test
    @DisplayName(""Test with set having overlapping characters"")
    void testCountSetWithOverlappingChars() {
        String str = ""hello"";
        String[] set = {""he"", ""ll""};
        assertEquals(5, charSetUtils.count(str, set), ""Count should be 5 for overlapping set elements"");
    }

    // --- Custom Cases ---

    @Test
    @DisplayName(""Test with unique characters"")
    void testCountUniqueCharacters() {
        String str = ""abcdefg"";
        String[] set = {""a"", ""b"", ""c""};
        assertEquals(3, charSetUtils.count(str, set), ""Count should be 3 for unique characters in set"");
    }

    @Test
    @DisplayName(""Test with no matching characters"")
    void testCountNoMatchingCharacters() {
        String str = ""hello"";
        String[] set = {""x"", ""y"", ""z""};
        assertEquals(0, charSetUtils.count(str, set), ""Count should be 0 when no characters match"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java"
"org.apache.commons.lang3.CharRange.access$300(org.apache.commons.lang3.CharRange)","char access$300(org.apache.commons.lang3.CharRange)","{
    org.apache.commons.lang3.CharRange x0;
    unknown $stack1;


    x0 := @parameter0: org.apache.commons.lang3.CharRange;
    $stack1 = x0.<org.apache.commons.lang3.CharRange: char end>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class's access$300 method.
 * Covers typical, edge, and potential error cases.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initialize charRange. In this context, assume there's a constructor or method to set the end character.
        charRange = new CharRange('a', 'z'); // Example initialization
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test retrieving the end character of a typical char range"")
    void testAccessEndCharacter() {
        charRange = new CharRange('a', 'z');
        assertEquals('z', CharRange.access$300(charRange), ""End character should be 'z' for range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test retrieving the end character for a single character range"")
    void testSingleCharacterRange() {
        charRange = new CharRange('x', 'x');
        assertEquals('x', CharRange.access$300(charRange), ""End character should be 'x' for range 'x' to 'x'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test retrieving the end character for numeric char range"")
    void testNumericCharRange() {
        charRange = new CharRange('0', '9');
        assertEquals('9', CharRange.access$300(charRange), ""End character should be '9' for range '0' to '9'"");
    }

    @Test
    @DisplayName(""Test retrieving the end character for special character range"")
    void testSpecialCharacterRange() {
        charRange = new CharRange('!', '/');
        assertEquals('/', CharRange.access$300(charRange), ""End character should be '/' for range '!' to '/'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test retrieving the end character when CharRange is null"")
    void testNullCharRange() {
        CharRange charRange = null;
        assertThrows(NullPointerException.class, () -> {
            CharRange.access$300(charRange);
        }, ""Should throw NullPointerException for null CharRange"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class's access$300 method.
 * Covers typical, edge, and potential error cases.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initialize charRange. In this context, assume there's a constructor or method to set the end character.
        charRange = new CharRange('a', 'z'); // Example initialization
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test retrieving the end character of a typical char range"")
    void testAccessEndCharacter() {
        charRange = new CharRange('a', 'z');
        assertEquals('z', CharRange.access$300(charRange), ""End character should be 'z' for range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test retrieving the end character for a single character range"")
    void testSingleCharacterRange() {
        charRange = new CharRange('x', 'x');
        assertEquals('x', CharRange.access$300(charRange), ""End character should be 'x' for range 'x' to 'x'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test retrieving the end character for numeric char range"")
    void testNumericCharRange() {
        charRange = new CharRange('0', '9');
        assertEquals('9', CharRange.access$300(charRange), ""End character should be '9' for range '0' to '9'"");
    }

    @Test
    @DisplayName(""Test retrieving the end character for special character range"")
    void testSpecialCharacterRange() {
        charRange = new CharRange('!', '/');
        assertEquals('/', CharRange.access$300(charRange), ""End character should be '/' for range '!' to '/'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test retrieving the end character when CharRange is null"")
    void testNullCharRange() {
        CharRange charRange = null;
        assertThrows(NullPointerException.class, () -> {
            CharRange.access$300(charRange);
        }, ""Should throw NullPointerException for null CharRange"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.getStart()","char getStart()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack1;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z'); // Example initialization
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test getStart returns correct start character"")
    void testGetStartTypical() {
        assertEquals('a', charRange.getStart(), ""Start should be 'a' for the initialized range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test getStart for numeric character range"")
    void testGetStartNumeric() {
        charRange = new CharRange('1', '5');
        assertEquals('1', charRange.getStart(), ""Start should be '1' for the range '1' to '5'"");
    }

    @Test
    @DisplayName(""Test getStart for single character range"")
    void testGetStartSingleCharacter() {
        charRange = new CharRange('x', 'x');
        assertEquals('x', charRange.getStart(), ""Start should be 'x' for the single character range 'x'"");
    }

    @Test
    @DisplayName(""Test getStart for non-ASCII characters"")
    void testGetStartNonAscii() {
        charRange = new CharRange('á', 'é');
        assertEquals('á', charRange.getStart(), ""Start should be 'á' for the range 'á' to 'é'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test getStart for range with negative width"")
    void testGetStartNegativeWidth() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            new CharRange('z', 'a');
        }, ""Should throw IllegalArgumentException for range with negative width"");

        assertTrue(exception.getMessage().contains(""Invalid character range""), ""Exception message should indicate invalid range"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z'); // Example initialization
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test getStart returns correct start character"")
    void testGetStartTypical() {
        assertEquals('a', charRange.getStart(), ""Start should be 'a' for the initialized range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test getStart for numeric character range"")
    void testGetStartNumeric() {
        charRange = new CharRange('1', '5');
        assertEquals('1', charRange.getStart(), ""Start should be '1' for the range '1' to '5'"");
    }

    @Test
    @DisplayName(""Test getStart for single character range"")
    void testGetStartSingleCharacter() {
        charRange = new CharRange('x', 'x');
        assertEquals('x', charRange.getStart(), ""Start should be 'x' for the single character range 'x'"");
    }

    @Test
    @DisplayName(""Test getStart for non-ASCII characters"")
    void testGetStartNonAscii() {
        charRange = new CharRange('á', 'é');
        assertEquals('á', charRange.getStart(), ""Start should be 'á' for the range 'á' to 'é'"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test getStart for range with negative width"")
    void testGetStartNegativeWidth() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            new CharRange('z', 'a');
        }, ""Should throw IllegalArgumentException for range with negative width"");

        assertTrue(exception.getMessage().contains(""Invalid character range""), ""Exception message should indicate invalid range"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.isNotIn(char, char)","org.apache.commons.lang3.CharRange isNotIn(char, char)","{
    char end, start;
    unknown $stack2;


    start := @parameter0: char;
    end := @parameter1: char;
    $stack2 = new org.apache.commons.lang3.CharRange;
    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char,char,boolean)>(start, end, 1);

    return $stack2;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corners, and validation handling.
 */
class CharRangeTest {

    // No need for setUp as isNotIn() is static and returns a new CharRange

    // TYPICAL CASES

    @Test
    @DisplayName(""Testing range creation from a to z"")
    void testRangeAtoZ() {
        CharRange range = CharRange.isNotIn('a', 'z');
        assertNotNull(range, ""Range should not be null for valid input"");
        assertEquals(""a-z"", range.toString(), ""Range string should be 'a-z'"");
    }

    @Test
    @DisplayName(""Testing range creation from A to Z"")
    void testRangeAToZUppercase() {
        CharRange range = CharRange.isNotIn('A', 'Z');
        assertNotNull(range, ""Range should not be null for valid input"");
        assertEquals(""A-Z"", range.toString(), ""Range string should be 'A-Z'"");
    }

    // EDGE CASES (Boundary values)

    @Test
    @DisplayName(""Testing range creation for single character 'a'"")
    void testRangeSingleChar() {
        CharRange range = CharRange.isNotIn('a', 'a');
        assertNotNull(range, ""Range should not be null for a single character"");
        assertEquals(""a"", range.toString(), ""Range string should be 'a'"");
    }

    // EDGE CASES (Special chars)

    @Test
    @DisplayName(""Testing range creation for special characters"")
    void testRangeSpecialChars() {
        CharRange range = CharRange.isNotIn('@', '[');
        assertNotNull(range, ""Range should not be null for special characters"");
        assertEquals(""@-["", range.toString(), ""Range string should be '@-['"");
    }

    // CORNER CASES (Reverse ranges)

    @Test
    @DisplayName(""Testing range creation where start is greater than end"")
    void testRangeReverse() {
        assertThrows(IllegalArgumentException.class, () -> {
            CharRange.isNotIn('z', 'a');
        }, ""Should throw IllegalArgumentException for invalid range parameters"");
    }

    // EDGE CASES (Unicode chars)

    @Test
    @DisplayName(""Testing range creation with Unicode characters"")
    void testRangeUnicode() {
        CharRange range = CharRange.isNotIn('\u00A0', '\u00FF');
        assertNotNull(range, ""Range should not be null for Unicode characters"");
        assertEquals(""\u00A0-\u00FF"", range.toString(), ""Range string should be '\\u00A0-\\u00FF'"");
    }

    @Test
    @DisplayName(""Test empty range handling"")
    void testRangeEmptyCase() {
        CharRange range = CharRange.isNotIn('m', 'n');
        assertNotNull(range, ""Range should not be null for close consecutive characters"");
        assertTrue(range.contains('o'), ""Should return true for characters not in the close range defined"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corners, and validation handling.
 */
class CharRangeTest {

    // No need for setUp as isNotIn() is static and returns a new CharRange

    // TYPICAL CASES

    @Test
    @DisplayName(""Testing range creation from a to z"")
    void testRangeAtoZ() {
        CharRange range = CharRange.isNotIn('a', 'z');
        assertNotNull(range, ""Range should not be null for valid input"");
        assertEquals(""a-z"", range.toString(), ""Range string should be 'a-z'"");
    }

    @Test
    @DisplayName(""Testing range creation from A to Z"")
    void testRangeAToZUppercase() {
        CharRange range = CharRange.isNotIn('A', 'Z');
        assertNotNull(range, ""Range should not be null for valid input"");
        assertEquals(""A-Z"", range.toString(), ""Range string should be 'A-Z'"");
    }

    // EDGE CASES (Boundary values)

    @Test
    @DisplayName(""Testing range creation for single character 'a'"")
    void testRangeSingleChar() {
        CharRange range = CharRange.isNotIn('a', 'a');
        assertNotNull(range, ""Range should not be null for a single character"");
        assertEquals(""a"", range.toString(), ""Range string should be 'a'"");
    }

    // EDGE CASES (Special chars)

    @Test
    @DisplayName(""Testing range creation for special characters"")
    void testRangeSpecialChars() {
        CharRange range = CharRange.isNotIn('@', '[');
        assertNotNull(range, ""Range should not be null for special characters"");
        assertEquals(""@-["", range.toString(), ""Range string should be '@-['"");
    }

    // CORNER CASES (Reverse ranges)

    @Test
    @DisplayName(""Testing range creation where start is greater than end"")
    void testRangeReverse() {
        assertThrows(IllegalArgumentException.class, () -> {
            CharRange.isNotIn('z', 'a');
        }, ""Should throw IllegalArgumentException for invalid range parameters"");
    }

    // EDGE CASES (Unicode chars)

    @Test
    @DisplayName(""Testing range creation with Unicode characters"")
    void testRangeUnicode() {
        CharRange range = CharRange.isNotIn('\u00A0', '\u00FF');
        assertNotNull(range, ""Range should not be null for Unicode characters"");
        assertEquals(""\u00A0-\u00FF"", range.toString(), ""Range string should be '\\u00A0-\\u00FF'"");
    }

    @Test
    @DisplayName(""Test empty range handling"")
    void testRangeEmptyCase() {
        CharRange range = CharRange.isNotIn('m', 'n');
        assertNotNull(range, ""Range should not be null for close consecutive characters"");
        assertTrue(range.contains('o'), ""Should return true for characters not in the close range defined"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.isNegated()","boolean isNegated()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack1;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack1 = this.<org.apache.commons.lang3.CharRange: boolean negated>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class focusing on isNegated method.
 * Covers typical cases and edge cases.
 */
class CharRangeTest {

    private CharRange charRangeNegated;
    private CharRange charRangeNonNegated;

    @BeforeEach
    void setUp() {
        // Assume these constructors set the 'negated' field
        charRangeNegated = new CharRange('a', 'z', true);
        charRangeNonNegated = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test isNegated for a negated CharRange"")
    void testIsNegatedForNegatedRange() {
        assertTrue(charRangeNegated.isNegated(), ""Expected isNegated to return true for a negated CharRange"");
    }

    @Test
    @DisplayName(""Test isNegated for a non-negated CharRange"")
    void testIsNegatedForNonNegatedRange() {
        assertFalse(charRangeNonNegated.isNegated(), ""Expected isNegated to return false for a non-negated CharRange"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test isNegated when CharRange is min"")
    void testIsNegatedForEdgeMinCharRange() {
        CharRange edgeMinRange = new CharRange(Character.MIN_VALUE, Character.MIN_VALUE, true);
        assertTrue(edgeMinRange.isNegated(), ""Expected isNegated to return true for a negated CharRange with minimum character"");
    }

    @Test
    @DisplayName(""Test isNegated when CharRange is max"")
    void testIsNegatedForEdgeMaxCharRange() {
        CharRange edgeMaxRange = new CharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        assertFalse(edgeMaxRange.isNegated(), ""Expected isNegated to return false for a non-negated CharRange with maximum character"");
    }

    @Test
    @DisplayName(""Test isNegated for CharRange with single element"")
    void testIsNegatedForSingleElementCharRange() {
        CharRange singleElementRange = new CharRange('a', 'a', false);
        assertFalse(singleElementRange.isNegated(), ""Expected isNegated to return false for a non-negated single-element CharRange"");

        CharRange negatedSingleElementRange = new CharRange('a', 'a', true);
        assertTrue(negatedSingleElementRange.isNegated(), ""Expected isNegated to return true for a negated single-element CharRange"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class focusing on isNegated method.
 * Covers typical cases and edge cases.
 */
class CharRangeTest {

    private CharRange charRangeNegated;
    private CharRange charRangeNonNegated;

    @BeforeEach
    void setUp() {
        // Assume these constructors set the 'negated' field
        charRangeNegated = new CharRange('a', 'z', true);
        charRangeNonNegated = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test isNegated for a negated CharRange"")
    void testIsNegatedForNegatedRange() {
        assertTrue(charRangeNegated.isNegated(), ""Expected isNegated to return true for a negated CharRange"");
    }

    @Test
    @DisplayName(""Test isNegated for a non-negated CharRange"")
    void testIsNegatedForNonNegatedRange() {
        assertFalse(charRangeNonNegated.isNegated(), ""Expected isNegated to return false for a non-negated CharRange"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test isNegated when CharRange is min"")
    void testIsNegatedForEdgeMinCharRange() {
        CharRange edgeMinRange = new CharRange(Character.MIN_VALUE, Character.MIN_VALUE, true);
        assertTrue(edgeMinRange.isNegated(), ""Expected isNegated to return true for a negated CharRange with minimum character"");
    }

    @Test
    @DisplayName(""Test isNegated when CharRange is max"")
    void testIsNegatedForEdgeMaxCharRange() {
        CharRange edgeMaxRange = new CharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        assertFalse(edgeMaxRange.isNegated(), ""Expected isNegated to return false for a non-negated CharRange with maximum character"");
    }

    @Test
    @DisplayName(""Test isNegated for CharRange with single element"")
    void testIsNegatedForSingleElementCharRange() {
        CharRange singleElementRange = new CharRange('a', 'a', false);
        assertFalse(singleElementRange.isNegated(), ""Expected isNegated to return false for a non-negated single-element CharRange"");

        CharRange negatedSingleElementRange = new CharRange('a', 'a', true);
        assertTrue(negatedSingleElementRange.isNegated(), ""Expected isNegated to return true for a negated single-element CharRange"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.access$100(org.apache.commons.lang3.CharRange)","boolean access$100(org.apache.commons.lang3.CharRange)","{
    org.apache.commons.lang3.CharRange x0;
    unknown $stack1;


    x0 := @parameter0: org.apache.commons.lang3.CharRange;
    $stack1 = x0.<org.apache.commons.lang3.CharRange: boolean negated>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, including edge and error cases.
 */
class CharRangeAccessTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initializing a default CharRange object for testing
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test negated is false for a typical CharRange"")
    void testAccess100NegatedFalse() {
        assertFalse(CharRange.access$100(charRange), ""Negated should be false for typical CharRange"");
    }

    @Test
    @DisplayName(""Test negated is true for a CharRange"")
    void testAccess100NegatedTrue() {
        charRange = new CharRange('a', 'z', true);
        assertTrue(CharRange.access$100(charRange), ""Negated should be true for negated CharRange"");
    }

    // EDGE CASES (Boundaries)

    @Test
    @DisplayName(""Test negated is false for a CharRange with single character"")
    void testAccess100SingleCharacter() {
        charRange = new CharRange('a', 'a', false);
        assertFalse(CharRange.access$100(charRange), ""Negated should be false for single character CharRange"");
    }

    @Test
    @DisplayName(""Test negated is true for a CharRange with single character and negated"")
    void testAccess100SingleCharacterNegated() {
        charRange = new CharRange('a', 'a', true);
        assertTrue(CharRange.access$100(charRange), ""Negated should be true for negated single character CharRange"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test handling of null CharRange"")
    void testAccess100NullCharRange() {
        CharRange nullCharRange = null;
        assertThrows(NullPointerException.class, () -> CharRange.access$100(nullCharRange),
                ""Should throw NullPointerException for null CharRange"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, including edge and error cases.
 */
class CharRangeAccessTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initializing a default CharRange object for testing
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test negated is false for a typical CharRange"")
    void testAccess100NegatedFalse() {
        assertFalse(CharRange.access$100(charRange), ""Negated should be false for typical CharRange"");
    }

    @Test
    @DisplayName(""Test negated is true for a CharRange"")
    void testAccess100NegatedTrue() {
        charRange = new CharRange('a', 'z', true);
        assertTrue(CharRange.access$100(charRange), ""Negated should be true for negated CharRange"");
    }

    // EDGE CASES (Boundaries)

    @Test
    @DisplayName(""Test negated is false for a CharRange with single character"")
    void testAccess100SingleCharacter() {
        charRange = new CharRange('a', 'a', false);
        assertFalse(CharRange.access$100(charRange), ""Negated should be false for single character CharRange"");
    }

    @Test
    @DisplayName(""Test negated is true for a CharRange with single character and negated"")
    void testAccess100SingleCharacterNegated() {
        charRange = new CharRange('a', 'a', true);
        assertTrue(CharRange.access$100(charRange), ""Negated should be true for negated single character CharRange"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test handling of null CharRange"")
    void testAccess100NullCharRange() {
        CharRange nullCharRange = null;
        assertThrows(NullPointerException.class, () -> CharRange.access$100(nullCharRange),
                ""Should throw NullPointerException for null CharRange"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeAccessTest.java"
"org.apache.commons.lang3.CharRange.access$200(org.apache.commons.lang3.CharRange)","char access$200(org.apache.commons.lang3.CharRange)","{
    org.apache.commons.lang3.CharRange x0;
    unknown $stack1;


    x0 := @parameter0: org.apache.commons.lang3.CharRange;
    $stack1 = x0.<org.apache.commons.lang3.CharRange: char start>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class focusing on access$200 method.
 * Covers typical cases and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Assuming a constructor or method to create instances of CharRange is available.
        charRange = CharRange.is('a'); // replace this with actual way to create CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test access$200 returns the start character"")
    void testAccess200ReturnsStart() {
        // Assumes CharRange has a method or way to verify the 'start' character.
        char start = 'a'; // This should be the expected start character
        assertEquals(start, CharRange.access$200(charRange), ""Should return the correct start character"");
    }

    // ERROR CASES (Invalid Input)

    @Test
    @DisplayName(""Test access$200 with null CharRange"")
    void testAccess200WithNullCharRange() {
        CharRange nullCharRange = null;
        assertThrows(NullPointerException.class, () -> {
            CharRange.access$200(nullCharRange);
        }, ""Should throw NullPointerException for null CharRange"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class focusing on access$200 method.
 * Covers typical cases and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Assuming a constructor or method to create instances of CharRange is available.
        charRange = CharRange.is('a'); // replace this with actual way to create CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test access$200 returns the start character"")
    void testAccess200ReturnsStart() {
        // Assumes CharRange has a method or way to verify the 'start' character.
        char start = 'a'; // This should be the expected start character
        assertEquals(start, CharRange.access$200(charRange), ""Should return the correct start character"");
    }

    // ERROR CASES (Invalid Input)

    @Test
    @DisplayName(""Test access$200 with null CharRange"")
    void testAccess200WithNullCharRange() {
        CharRange nullCharRange = null;
        assertThrows(NullPointerException.class, () -> {
            CharRange.access$200(nullCharRange);
        }, ""Should throw NullPointerException for null CharRange"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.getEnd()","char getEnd()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack1;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack1 = this.<org.apache.commons.lang3.CharRange: char end>;

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class's getEnd method.
 * Covers typical cases and edge cases.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Example initialization, assuming CharRange has a constructor that takes start and end
        charRange = new CharRange('a', 'z');
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test getEnd for typical char range"")
    void testGetEndTypical() {
        assertEquals('z', charRange.getEnd(), ""End should be 'z' for range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test getEnd for single character range"")
    void testGetEndSingleCharacterRange() {
        charRange = new CharRange('e', 'e');
        assertEquals('e', charRange.getEnd(), ""End should be 'e' for range 'e' to 'e'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is a special character"")
    void testGetEndSpecialCharacter() {
        charRange = new CharRange(' ', '~'); // ASCII character range
        assertEquals('~', charRange.getEnd(), ""End should be '~' for range ' ' to '~'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is a non-printable character"")
    void testGetEndNonPrintableCharacter() {
        charRange = new CharRange('\u0000', '\u0007'); // Control chars range
        assertEquals('\u0007', charRange.getEnd(), ""End should be '\u0007' for range '\u0000' to '\u0007'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is the maximum char value"")
    void testGetEndMaxCharValue() {
        charRange = new CharRange('a', Character.MAX_VALUE);
        assertEquals(Character.MAX_VALUE, charRange.getEnd(), ""End should be Character.MAX_VALUE for range 'a' to Character.MAX_VALUE"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class's getEnd method.
 * Covers typical cases and edge cases.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Example initialization, assuming CharRange has a constructor that takes start and end
        charRange = new CharRange('a', 'z');
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test getEnd for typical char range"")
    void testGetEndTypical() {
        assertEquals('z', charRange.getEnd(), ""End should be 'z' for range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test getEnd for single character range"")
    void testGetEndSingleCharacterRange() {
        charRange = new CharRange('e', 'e');
        assertEquals('e', charRange.getEnd(), ""End should be 'e' for range 'e' to 'e'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is a special character"")
    void testGetEndSpecialCharacter() {
        charRange = new CharRange(' ', '~'); // ASCII character range
        assertEquals('~', charRange.getEnd(), ""End should be '~' for range ' ' to '~'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is a non-printable character"")
    void testGetEndNonPrintableCharacter() {
        charRange = new CharRange('\u0000', '\u0007'); // Control chars range
        assertEquals('\u0007', charRange.getEnd(), ""End should be '\u0007' for range '\u0000' to '\u0007'"");
    }

    @Test
    @DisplayName(""Test getEnd when end is the maximum char value"")
    void testGetEndMaxCharValue() {
        charRange = new CharRange('a', Character.MAX_VALUE);
        assertEquals(Character.MAX_VALUE, charRange.getEnd(), ""End should be Character.MAX_VALUE for range 'a' to Character.MAX_VALUE"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.hashCode()","int hashCode()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack1, $stack2, $stack3, $stack4, $stack5, $stack6, $stack7, $stack8;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack4 = 83 + $stack1;
    $stack2 = this.<org.apache.commons.lang3.CharRange: char end>;
    $stack3 = 7 * $stack2;
    $stack6 = $stack4 + $stack3;
    $stack5 = this.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack5 == 0 goto label1;
    $stack8 = 1;

    goto label2;

  label1:
    $stack8 = 0;

  label2:
    $stack7 = $stack6 + $stack8;

    return $stack7;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and logic validation.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Setup will be done in individual tests with different configurations
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test hashCode with non-negated range"")
    void testHashCodeNonNegated() {
        charRange = new CharRange('a', 'z', false);
        int expectedHashCode = (83 + 'a') + (7 * 'z') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for non-negated range"");
    }

    @Test
    @DisplayName(""Test hashCode with negated range"")
    void testHashCodeNegated() {
        charRange = new CharRange('a', 'z', true);
        int expectedHashCode = (83 + 'a') + (7 * 'z') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for negated range"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test hashCode with start and end as same character (non-negated)"")
    void testHashCodeSingleCharNonNegated() {
        charRange = new CharRange('a', 'a', false);
        int expectedHashCode = (83 + 'a') + (7 * 'a') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for single character range"");
    }

    @Test
    @DisplayName(""Test hashCode with start and end as same character (negated)"")
    void testHashCodeSingleCharNegated() {
        charRange = new CharRange('a', 'a', true);
        int expectedHashCode = (83 + 'a') + (7 * 'a') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for single character range, negated"");
    }

    @Test
    @DisplayName(""Test hashCode with Unicode boundary values (non-negated)"")
    void testHashCodeUnicodeBoundariesNonNegated() {
        charRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        int expectedHashCode = (83 + Character.MIN_VALUE) + (7 * Character.MAX_VALUE) + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for Unicode boundary values, non-negated"");
    }

    @Test
    @DisplayName(""Test hashCode with Unicode boundary values (negated)"")
    void testHashCodeUnicodeBoundariesNegated() {
        charRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        int expectedHashCode = (83 + Character.MIN_VALUE) + (7 * Character.MAX_VALUE) + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for Unicode boundary values, negated"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test hashCode with start greater than end (invalid range)"")
    void testHashCodeStartGreaterThanEnd() {
        charRange = new CharRange('z', 'a', false);
        int expectedHashCode = (83 + 'z') + (7 * 'a') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash computation should still work for start greater than end"");
    }

    @Test
    @DisplayName(""Test hashCode with start greater than end (negated)"")
    void testHashCodeStartGreaterThanEndNegated() {
        charRange = new CharRange('z', 'a', true);
        int expectedHashCode = (83 + 'z') + (7 * 'a') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash computation should still work for start greater than end, negated"");
    }

}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and logic validation.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Setup will be done in individual tests with different configurations
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test hashCode with non-negated range"")
    void testHashCodeNonNegated() {
        charRange = new CharRange('a', 'z', false);
        int expectedHashCode = (83 + 'a') + (7 * 'z') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for non-negated range"");
    }

    @Test
    @DisplayName(""Test hashCode with negated range"")
    void testHashCodeNegated() {
        charRange = new CharRange('a', 'z', true);
        int expectedHashCode = (83 + 'a') + (7 * 'z') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for negated range"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test hashCode with start and end as same character (non-negated)"")
    void testHashCodeSingleCharNonNegated() {
        charRange = new CharRange('a', 'a', false);
        int expectedHashCode = (83 + 'a') + (7 * 'a') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for single character range"");
    }

    @Test
    @DisplayName(""Test hashCode with start and end as same character (negated)"")
    void testHashCodeSingleCharNegated() {
        charRange = new CharRange('a', 'a', true);
        int expectedHashCode = (83 + 'a') + (7 * 'a') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for single character range, negated"");
    }

    @Test
    @DisplayName(""Test hashCode with Unicode boundary values (non-negated)"")
    void testHashCodeUnicodeBoundariesNonNegated() {
        charRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        int expectedHashCode = (83 + Character.MIN_VALUE) + (7 * Character.MAX_VALUE) + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for Unicode boundary values, non-negated"");
    }

    @Test
    @DisplayName(""Test hashCode with Unicode boundary values (negated)"")
    void testHashCodeUnicodeBoundariesNegated() {
        charRange = new CharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        int expectedHashCode = (83 + Character.MIN_VALUE) + (7 * Character.MAX_VALUE) + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash should match expected for Unicode boundary values, negated"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test hashCode with start greater than end (invalid range)"")
    void testHashCodeStartGreaterThanEnd() {
        charRange = new CharRange('z', 'a', false);
        int expectedHashCode = (83 + 'z') + (7 * 'a') + 0;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash computation should still work for start greater than end"");
    }

    @Test
    @DisplayName(""Test hashCode with start greater than end (negated)"")
    void testHashCodeStartGreaterThanEndNegated() {
        charRange = new CharRange('z', 'a', true);
        int expectedHashCode = (83 + 'z') + (7 * 'a') + 1;
        assertEquals(expectedHashCode, charRange.hashCode(), ""Hash computation should still work for start greater than end, negated"");
    }

}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.contains(char)","boolean contains(char)","{
    char ch;
    org.apache.commons.lang3.CharRange this;
    unknown $stack2, $stack3, $stack4, $stack5, $stack6, $stack7;


    this := @this: org.apache.commons.lang3.CharRange;
    ch := @parameter0: char;
    $stack2 = this.<org.apache.commons.lang3.CharRange: char start>;

    if ch < $stack2 goto label1;
    $stack5 = this.<org.apache.commons.lang3.CharRange: char end>;

    if ch > $stack5 goto label1;
    $stack7 = 1;

    goto label2;

  label1:
    $stack7 = 0;

  label2:
    $stack6 = this;
    $stack3 = this.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack7 == $stack3 goto label3;
    $stack4 = 1;

    goto label4;

  label3:
    $stack4 = 0;

  label4:
    return $stack4;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and negated ranges.
 */
class CharRangeTest {

    private CharRange charRange;
    private CharRange negatedCharRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);  // Non-negated range
        negatedCharRange = new CharRange('a', 'z', true);  // Negated range
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test character containment within a non-negated range (typical)"")
    void testContainsWithinRange() {
        assertTrue(charRange.contains('m'), ""Character 'm' should be within range 'a' to 'z'"");
        assertTrue(charRange.contains('a'), ""Character 'a' should be within range 'a' to 'z'"");
        assertTrue(charRange.contains('z'), ""Character 'z' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character containment outside a non-negated range"")
    void testDoesNotContainOutsideRange() {
        assertFalse(charRange.contains('A'), ""Character 'A' should not be within range 'a' to 'z'"");
        assertFalse(charRange.contains('Z'), ""Character 'Z' should not be within range 'a' to 'z'"");
        assertFalse(charRange.contains('{'), ""Character '{' should not be within range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test character at the start of the range"")
    void testStartOfRange() {
        assertTrue(charRange.contains('a'), ""Character 'a' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character at the end of the range"")
    void testEndOfRange() {
        assertTrue(charRange.contains('z'), ""Character 'z' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character just before the start of the range"")
    void testBeforeStartOfRange() {
        assertFalse(charRange.contains('`'), ""Character '`' should not be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character just after the end of the range"")
    void testAfterEndOfRange() {
        assertFalse(charRange.contains('{'), ""Character '{' should not be within range 'a' to 'z'"");
    }

    // CORNER CASES (Negated Ranges)

    @Test
    @DisplayName(""Test character containment within a negated range"")
    void testContainsWithinNegatedRange() {
        assertFalse(negatedCharRange.contains('m'), ""Character 'm' should not be within negated range 'a' to 'z'"");
        assertFalse(negatedCharRange.contains('a'), ""Character 'a' should not be within negated range 'a' to 'z'"");
        assertFalse(negatedCharRange.contains('z'), ""Character 'z' should not be within negated range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character containment outside a negated range"")
    void testDoesNotContainOutsideNegatedRange() {
        assertTrue(negatedCharRange.contains('A'), ""Character 'A' should be within negated range (not 'a' to 'z')"");
        assertTrue(negatedCharRange.contains('Z'), ""Character 'Z' should be within negated range (not 'a' to 'z')"");
        assertTrue(negatedCharRange.contains('{'), ""Character '{' should be within negated range (not 'a' to 'z')"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and negated ranges.
 */
class CharRangeTest {

    private CharRange charRange;
    private CharRange negatedCharRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);  // Non-negated range
        negatedCharRange = new CharRange('a', 'z', true);  // Negated range
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test character containment within a non-negated range (typical)"")
    void testContainsWithinRange() {
        assertTrue(charRange.contains('m'), ""Character 'm' should be within range 'a' to 'z'"");
        assertTrue(charRange.contains('a'), ""Character 'a' should be within range 'a' to 'z'"");
        assertTrue(charRange.contains('z'), ""Character 'z' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character containment outside a non-negated range"")
    void testDoesNotContainOutsideRange() {
        assertFalse(charRange.contains('A'), ""Character 'A' should not be within range 'a' to 'z'"");
        assertFalse(charRange.contains('Z'), ""Character 'Z' should not be within range 'a' to 'z'"");
        assertFalse(charRange.contains('{'), ""Character '{' should not be within range 'a' to 'z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test character at the start of the range"")
    void testStartOfRange() {
        assertTrue(charRange.contains('a'), ""Character 'a' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character at the end of the range"")
    void testEndOfRange() {
        assertTrue(charRange.contains('z'), ""Character 'z' should be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character just before the start of the range"")
    void testBeforeStartOfRange() {
        assertFalse(charRange.contains('`'), ""Character '`' should not be within range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character just after the end of the range"")
    void testAfterEndOfRange() {
        assertFalse(charRange.contains('{'), ""Character '{' should not be within range 'a' to 'z'"");
    }

    // CORNER CASES (Negated Ranges)

    @Test
    @DisplayName(""Test character containment within a negated range"")
    void testContainsWithinNegatedRange() {
        assertFalse(negatedCharRange.contains('m'), ""Character 'm' should not be within negated range 'a' to 'z'"");
        assertFalse(negatedCharRange.contains('a'), ""Character 'a' should not be within negated range 'a' to 'z'"");
        assertFalse(negatedCharRange.contains('z'), ""Character 'z' should not be within negated range 'a' to 'z'"");
    }

    @Test
    @DisplayName(""Test character containment outside a negated range"")
    void testDoesNotContainOutsideNegatedRange() {
        assertTrue(negatedCharRange.contains('A'), ""Character 'A' should be within negated range (not 'a' to 'z')"");
        assertTrue(negatedCharRange.contains('Z'), ""Character 'Z' should be within negated range (not 'a' to 'z')"");
        assertTrue(negatedCharRange.contains('{'), ""Character '{' should be within negated range (not 'a' to 'z')"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.iterator()","java.util.Iterator iterator()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack1;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack1 = new org.apache.commons.lang3.CharRange$CharacterIterator;
    specialinvoke $stack1.<org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange,org.apache.commons.lang3.CharRange$1)>(this, null);

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Iterator;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = CharRange.is('a', 'z'); // Assuming a constructor or builder pattern exists for creating CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test iterator for normal character range"")
    void testIteratorNormalRange() {
        Iterator<Character> iterator = charRange.iterator();
        StringBuilder result = new StringBuilder();
        while (iterator.hasNext()) {
            result.append(iterator.next());
        }
        assertEquals(""abcdefghijklmnopqrstuvwxyz"", result.toString(), ""Iterating over a-z should output the complete alphabet"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test iterator for a single character range"")
    void testIteratorSingleCharacter() {
        charRange = CharRange.is('x', 'x');
        Iterator<Character> iterator = charRange.iterator();
        assertTrue(iterator.hasNext(), ""Iterator should have one next element"");
        assertEquals('x', iterator.next().charValue(), ""Single character range should return that character"");
        assertFalse(iterator.hasNext(), ""Iterator should not have more elements"");
    }

    @Test
    @DisplayName(""Test iterator for reverse order range (empty)"")
    void testIteratorReverseOrder() {
        charRange = CharRange.is('z', 'a');
        Iterator<Character> iterator = charRange.iterator();
        assertFalse(iterator.hasNext(), ""Reverse order range should be empty"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test behavior of iterator for null CharRange"")
    void testIteratorOnNullCharRange() {
        charRange = null;
        assertThrows(NullPointerException.class, () -> {
            Iterator<Character> iterator = charRange.iterator();
        }, ""Should throw NullPointerException for null CharRange"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Iterator;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = CharRange.is('a', 'z'); // Assuming a constructor or builder pattern exists for creating CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test iterator for normal character range"")
    void testIteratorNormalRange() {
        Iterator<Character> iterator = charRange.iterator();
        StringBuilder result = new StringBuilder();
        while (iterator.hasNext()) {
            result.append(iterator.next());
        }
        assertEquals(""abcdefghijklmnopqrstuvwxyz"", result.toString(), ""Iterating over a-z should output the complete alphabet"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test iterator for a single character range"")
    void testIteratorSingleCharacter() {
        charRange = CharRange.is('x', 'x');
        Iterator<Character> iterator = charRange.iterator();
        assertTrue(iterator.hasNext(), ""Iterator should have one next element"");
        assertEquals('x', iterator.next().charValue(), ""Single character range should return that character"");
        assertFalse(iterator.hasNext(), ""Iterator should not have more elements"");
    }

    @Test
    @DisplayName(""Test iterator for reverse order range (empty)"")
    void testIteratorReverseOrder() {
        charRange = CharRange.is('z', 'a');
        Iterator<Character> iterator = charRange.iterator();
        assertFalse(iterator.hasNext(), ""Reverse order range should be empty"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test behavior of iterator for null CharRange"")
    void testIteratorOnNullCharRange() {
        charRange = null;
        assertThrows(NullPointerException.class, () -> {
            Iterator<Character> iterator = charRange.iterator();
        }, ""Should throw NullPointerException for null CharRange"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.isIn(char, char)","org.apache.commons.lang3.CharRange isIn(char, char)","{
    char end, start;
    unknown $stack2;


    start := @parameter0: char;
    end := @parameter1: char;
    $stack2 = new org.apache.commons.lang3.CharRange;
    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char,char,boolean)>(start, end, 0);

    return $stack2;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and construction validation.
 */
class CharRangeTest {

    // CLASS UNDER TEST
    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // No specific setup needed, as each test constructs relevant CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test creating a CharRange with typical characters"")
    void testCharRangeWithTypicalChars() {
        char start = 'a';
        char end = 'z';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with typical characters"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating CharRange with single-character range"")
    void testCharRangeWithSingleChar() {
        char start = 'x';
        char end = 'x';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with single character range"");
    }

    @Test
    @DisplayName(""Test creating CharRange with reversed character order"")
    void testCharRangeWithReversedOrder() {
        char start = 'z';
        char end = 'a';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should handle reversed character order"");
    }

    // EDGE CASES (Boundary Values)

    @Test
    @DisplayName(""Test CharRange with boundary character values"")
    void testCharRangeBoundaryValues() {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with boundary character values"");
    }

    @Test
    @DisplayName(""Test CharRange with first character"")
    void testCharRangeWithFirstChar() {
        char start = 'a';
        char end = 'b';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed when using first possible character"");
    }

    @Test
    @DisplayName(""Test CharRange with last character"")
    void testCharRangeWithLastChar() {
        char start = 'y';
        char end = 'z';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed when using last possible character"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and construction validation.
 */
class CharRangeTest {

    // CLASS UNDER TEST
    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // No specific setup needed, as each test constructs relevant CharRange
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test creating a CharRange with typical characters"")
    void testCharRangeWithTypicalChars() {
        char start = 'a';
        char end = 'z';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with typical characters"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating CharRange with single-character range"")
    void testCharRangeWithSingleChar() {
        char start = 'x';
        char end = 'x';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with single character range"");
    }

    @Test
    @DisplayName(""Test creating CharRange with reversed character order"")
    void testCharRangeWithReversedOrder() {
        char start = 'z';
        char end = 'a';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should handle reversed character order"");
    }

    // EDGE CASES (Boundary Values)

    @Test
    @DisplayName(""Test CharRange with boundary character values"")
    void testCharRangeBoundaryValues() {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed with boundary character values"");
    }

    @Test
    @DisplayName(""Test CharRange with first character"")
    void testCharRangeWithFirstChar() {
        char start = 'a';
        char end = 'b';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed when using first possible character"");
    }

    @Test
    @DisplayName(""Test CharRange with last character"")
    void testCharRangeWithLastChar() {
        char start = 'y';
        char end = 'z';
        charRange = new CharRange(start, end, false);
        assertNotNull(charRange, ""CharRange creation should succeed when using last possible character"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.toString()","java.lang.String toString()","{
    org.apache.commons.lang3.CharRange this;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, $stack18, $stack19, $stack2, $stack20, $stack21, $stack3, $stack4, $stack5, $stack6, $stack7, $stack8, $stack9, buf;


    this := @this: org.apache.commons.lang3.CharRange;
    $stack2 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;

    if $stack2 != null goto label3;
    $stack4 = new java.lang.StringBuilder;
    specialinvoke $stack4.<java.lang.StringBuilder: void <init>(int)>(4);
    buf = $stack4;
    $stack5 = virtualinvoke this.<org.apache.commons.lang3.CharRange: boolean isNegated()>();

    if $stack5 == 0 goto label1;
    $stack17 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(94);

  label1:
    $stack19 = buf;
    $stack18 = this;
    $stack6 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack7 = virtualinvoke $stack19.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack6);
    $stack20 = this;
    $stack9 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack21 = this;
    $stack8 = this.<org.apache.commons.lang3.CharRange: char end>;

    if $stack9 == $stack8 goto label2;
    $stack12 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(45);
    $stack13 = this.<org.apache.commons.lang3.CharRange: char end>;
    $stack14 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack13);

  label2:
    $stack16 = this;
    $stack15 = buf;
    $stack10 = virtualinvoke $stack15.<java.lang.StringBuilder: java.lang.String toString()>();
    this.<org.apache.commons.lang3.CharRange: java.lang.String iToString> = $stack10;

  label3:
    $stack11 = this;
    $stack3 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;

    return $stack3;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and ensures correct string representation.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initialize to a default CharRange object. Specific ranges will be instantiated in individual tests.
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test toString for a normal range"")
    void testToStringNormalRange() {
        charRange = CharRange.is('a', 'z');
        assertEquals(""a-z"", charRange.toString(), ""Range from 'a' to 'z' should be 'a-z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test toString for a single character range"")
    void testToStringSingleCharacter() {
        charRange = CharRange.is('a');
        assertEquals(""a"", charRange.toString(), ""Single character range 'a' should be 'a'"");
    }

    @Test
    @DisplayName(""Test toString for a negated range"")
    void testToStringNegatedRange() {
        charRange = CharRange.isNot('x');
        assertEquals(""^x"", charRange.toString(), ""Negated single character 'x' should be '^x'"");
    }

    @Test
    @DisplayName(""Test toString for a range starting with special characters"")
    void testToStringSpecialCharacterStart() {
        charRange = CharRange.is('-', 'z');
        assertEquals(""--z"", charRange.toString(), ""Range from '-' to 'z' should be '--z'"");
    }

    @Test
    @DisplayName(""Test toString for a range ending with special characters"")
    void testToStringSpecialCharacterEnd() {
        charRange = CharRange.is('a', '-');
        assertEquals(""a--"", charRange.toString(), ""Range from 'a' to '-' should be 'a--'"");
    }

    @Test
    @DisplayName(""Test toString caching behavior"")
    void testToStringCaching() {
        charRange = CharRange.is('a', 'b');
        String firstCall = charRange.toString();
        String secondCall = charRange.toString();
        assertSame(firstCall, secondCall, ""Second call to toString should return the cached string representation"");
    }

}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and ensures correct string representation.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initialize to a default CharRange object. Specific ranges will be instantiated in individual tests.
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test toString for a normal range"")
    void testToStringNormalRange() {
        charRange = CharRange.is('a', 'z');
        assertEquals(""a-z"", charRange.toString(), ""Range from 'a' to 'z' should be 'a-z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test toString for a single character range"")
    void testToStringSingleCharacter() {
        charRange = CharRange.is('a');
        assertEquals(""a"", charRange.toString(), ""Single character range 'a' should be 'a'"");
    }

    @Test
    @DisplayName(""Test toString for a negated range"")
    void testToStringNegatedRange() {
        charRange = CharRange.isNot('x');
        assertEquals(""^x"", charRange.toString(), ""Negated single character 'x' should be '^x'"");
    }

    @Test
    @DisplayName(""Test toString for a range starting with special characters"")
    void testToStringSpecialCharacterStart() {
        charRange = CharRange.is('-', 'z');
        assertEquals(""--z"", charRange.toString(), ""Range from '-' to 'z' should be '--z'"");
    }

    @Test
    @DisplayName(""Test toString for a range ending with special characters"")
    void testToStringSpecialCharacterEnd() {
        charRange = CharRange.is('a', '-');
        assertEquals(""a--"", charRange.toString(), ""Range from 'a' to '-' should be 'a--'"");
    }

    @Test
    @DisplayName(""Test toString caching behavior"")
    void testToStringCaching() {
        charRange = CharRange.is('a', 'b');
        String firstCall = charRange.toString();
        String secondCall = charRange.toString();
        assertSame(firstCall, secondCall, ""Second call to toString should return the cached string representation"");
    }

}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.is(char)","org.apache.commons.lang3.CharRange is(char)","{
    char ch;
    unknown $stack1;


    ch := @parameter0: char;
    $stack1 = new org.apache.commons.lang3.CharRange;
    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char,char,boolean)>(ch, ch, 0);

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange((char) 0, (char) 0, false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test creating CharRange with a typical character"")
    void testCharRangeWithTypicalCharacter() {
        char ch = 'a';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent character 'a'"");
    }
    
    @Test
    @DisplayName(""Test creating CharRange with a numeric character"")
    void testCharRangeWithNumericCharacter() {
        char ch = '5';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent character '5'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating CharRange with a boundary character MAX_VALUE"")
    void testCharRangeWithMaxChar() {
        char ch = Character.MAX_VALUE;
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent max character value"");
    }

    @Test
    @DisplayName(""Test creating CharRange with a boundary character MIN_VALUE"")
    void testCharRangeWithMinChar() {
        char ch = Character.MIN_VALUE;
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent min character value"");
    }

    // SPECIAL CASES

    @Test
    @DisplayName(""Test creating CharRange with whitespace character"")
    void testCharRangeWithWhitespace() {
        char ch = ' ';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent whitespace character"");
    }

    @Test
    @DisplayName(""Test creating CharRange with a special character"")
    void testCharRangeWithSpecialCharacter() {
        char ch = '#';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent special character '#'"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange((char) 0, (char) 0, false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test creating CharRange with a typical character"")
    void testCharRangeWithTypicalCharacter() {
        char ch = 'a';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent character 'a'"");
    }
    
    @Test
    @DisplayName(""Test creating CharRange with a numeric character"")
    void testCharRangeWithNumericCharacter() {
        char ch = '5';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent character '5'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating CharRange with a boundary character MAX_VALUE"")
    void testCharRangeWithMaxChar() {
        char ch = Character.MAX_VALUE;
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent max character value"");
    }

    @Test
    @DisplayName(""Test creating CharRange with a boundary character MIN_VALUE"")
    void testCharRangeWithMinChar() {
        char ch = Character.MIN_VALUE;
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent min character value"");
    }

    // SPECIAL CASES

    @Test
    @DisplayName(""Test creating CharRange with whitespace character"")
    void testCharRangeWithWhitespace() {
        char ch = ' ';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent whitespace character"");
    }

    @Test
    @DisplayName(""Test creating CharRange with a special character"")
    void testCharRangeWithSpecialCharacter() {
        char ch = '#';
        CharRange range = charRange.is(ch);
        assertEquals(new CharRange(ch, ch, false), range, ""Range should represent special character '#'"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.equals(java.lang.Object)","boolean equals(java.lang.Object)","{
    java.lang.Object obj;
    org.apache.commons.lang3.CharRange this;
    unknown $stack10, $stack3, $stack4, $stack5, $stack6, $stack7, $stack8, $stack9, other;


    this := @this: org.apache.commons.lang3.CharRange;
    obj := @parameter0: java.lang.Object;

    if obj != this goto label1;

    return 1;

  label1:
    $stack3 = obj instanceof org.apache.commons.lang3.CharRange;

    if $stack3 != 0 goto label2;

    return 0;

  label2:
    other = (org.apache.commons.lang3.CharRange) obj;
    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack4 = other.<org.apache.commons.lang3.CharRange: char start>;

    if $stack5 != $stack4 goto label3;
    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;
    $stack6 = other.<org.apache.commons.lang3.CharRange: char end>;

    if $stack7 != $stack6 goto label3;
    $stack10 = this.<org.apache.commons.lang3.CharRange: boolean negated>;
    $stack9 = other.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack10 != $stack9 goto label3;
    $stack8 = 1;

    goto label4;

  label3:
    $stack8 = 0;

  label4:
    return $stack8;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test equals method with same object reference"")
    void testEqualsSameObject() {
        assertTrue(charRange.equals(charRange), ""Equals should return true when comparing the same object reference"");
    }

    @Test
    @DisplayName(""Test equals method with different object types"")
    void testEqualsDifferentObjectType() {
        Object otherObject = new Object();
        assertFalse(charRange.equals(otherObject), ""Equals should return false when comparing with different object type"");
    }

    @Test
    @DisplayName(""Test equals method with identical CharRange objects"")
    void testEqualsIdenticalCharRange() {
        CharRange identicalCharRange = new CharRange('a', 'z', false);
        assertTrue(charRange.equals(identicalCharRange), ""Equals should return true for identical CharRange objects"");
    }

    @Test
    @DisplayName(""Test equals method with different start character"")
    void testEqualsDifferentStartChar() {
        CharRange differentStart = new CharRange('b', 'z', false);
        assertFalse(charRange.equals(differentStart), ""Equals should return false for different start character"");
    }

    @Test
    @DisplayName(""Test equals method with different end character"")
    void testEqualsDifferentEndChar() {
        CharRange differentEnd = new CharRange('a', 'y', false);
        assertFalse(charRange.equals(differentEnd), ""Equals should return false for different end character"");
    }

    @Test
    @DisplayName(""Test equals method with different negated value"")
    void testEqualsDifferentNegation() {
        CharRange differentNegation = new CharRange('a', 'z', true);
        assertFalse(charRange.equals(differentNegation), ""Equals should return false for different negated value"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test equals method with null"")
    void testEqualsNull() {
        assertFalse(charRange.equals(null), ""Equals should return false when comparing with null"");
    }

    @Test
    @DisplayName(""Test equals method with CharRange having the same start and end character"")
    void testEqualsSingleCharRange() {
        CharRange singleCharRange = new CharRange('a', 'a', false);
        CharRange identicalSingleCharRange = new CharRange('a', 'a', false);
        assertFalse(charRange.equals(singleCharRange), ""Equals should return false for different single character range"");
        assertTrue(singleCharRange.equals(identicalSingleCharRange), ""Equals should return true for identical single character range"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test equals method with same object reference"")
    void testEqualsSameObject() {
        assertTrue(charRange.equals(charRange), ""Equals should return true when comparing the same object reference"");
    }

    @Test
    @DisplayName(""Test equals method with different object types"")
    void testEqualsDifferentObjectType() {
        Object otherObject = new Object();
        assertFalse(charRange.equals(otherObject), ""Equals should return false when comparing with different object type"");
    }

    @Test
    @DisplayName(""Test equals method with identical CharRange objects"")
    void testEqualsIdenticalCharRange() {
        CharRange identicalCharRange = new CharRange('a', 'z', false);
        assertTrue(charRange.equals(identicalCharRange), ""Equals should return true for identical CharRange objects"");
    }

    @Test
    @DisplayName(""Test equals method with different start character"")
    void testEqualsDifferentStartChar() {
        CharRange differentStart = new CharRange('b', 'z', false);
        assertFalse(charRange.equals(differentStart), ""Equals should return false for different start character"");
    }

    @Test
    @DisplayName(""Test equals method with different end character"")
    void testEqualsDifferentEndChar() {
        CharRange differentEnd = new CharRange('a', 'y', false);
        assertFalse(charRange.equals(differentEnd), ""Equals should return false for different end character"");
    }

    @Test
    @DisplayName(""Test equals method with different negated value"")
    void testEqualsDifferentNegation() {
        CharRange differentNegation = new CharRange('a', 'z', true);
        assertFalse(charRange.equals(differentNegation), ""Equals should return false for different negated value"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test equals method with null"")
    void testEqualsNull() {
        assertFalse(charRange.equals(null), ""Equals should return false when comparing with null"");
    }

    @Test
    @DisplayName(""Test equals method with CharRange having the same start and end character"")
    void testEqualsSingleCharRange() {
        CharRange singleCharRange = new CharRange('a', 'a', false);
        CharRange identicalSingleCharRange = new CharRange('a', 'a', false);
        assertFalse(charRange.equals(singleCharRange), ""Equals should return false for different single character range"");
        assertTrue(singleCharRange.equals(identicalSingleCharRange), ""Equals should return true for identical single character range"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.isNot(char)","org.apache.commons.lang3.CharRange isNot(char)","{
    char ch;
    unknown $stack1;


    ch := @parameter0: char;
    $stack1 = new org.apache.commons.lang3.CharRange;
    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char,char,boolean)>(ch, ch, 1);

    return $stack1;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases and edge cases for creating character ranges with `isNot`.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initial setup if needed, but typically none for static methods.
    }

    // TYPICAL AND EDGE CASES

    @Test
    @DisplayName(""Test creating a negative CharRange for a single character"")
    void testIsNotSingleChar() {
        char ch = 'a';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for single character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for a numeric character"")
    void testIsNotNumericChar() {
        char ch = '5';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for numeric character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for a special character"")
    void testIsNotSpecialChar() {
        char ch = '#';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for special character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating a negative CharRange for whitespace character"")
    void testIsNotWhitespace() {
        char ch = ' ';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for whitespace character"");
        assertEquals(ch, charRange.getStart(), ""Start should be whitespace"");
        assertEquals(ch, charRange.getEnd(), ""End should be whitespace"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for boundary ASCII value"")
    void testIsNotBoundaryASCII() {
        char ch = 0;
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for boundary ASCII value"");
        assertEquals(ch, charRange.getStart(), ""Start should be boundary ASCII value"");
        assertEquals(ch, charRange.getEnd(), ""End should be boundary ASCII value"");

        ch = 127; // ASCII DEL character
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for ASCII DEL character"");
        assertEquals(ch, charRange.getStart(), ""Start should be ASCII DEL"");
        assertEquals(ch, charRange.getEnd(), ""End should be ASCII DEL"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for non-ASCII Unicode character"")
    void testIsNotNonASCIIUnicode() {
        char ch = '\u00A9'; // Copyright symbol
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for non-ASCII Unicode character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the Unicode character"");
        assertEquals(ch, charRange.getEnd(), ""End should be the Unicode character"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases and edge cases for creating character ranges with `isNot`.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        // Initial setup if needed, but typically none for static methods.
    }

    // TYPICAL AND EDGE CASES

    @Test
    @DisplayName(""Test creating a negative CharRange for a single character"")
    void testIsNotSingleChar() {
        char ch = 'a';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for single character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for a numeric character"")
    void testIsNotNumericChar() {
        char ch = '5';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for numeric character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for a special character"")
    void testIsNotSpecialChar() {
        char ch = '#';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for special character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the character itself"");
        assertEquals(ch, charRange.getEnd(), ""End should be the character itself"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test creating a negative CharRange for whitespace character"")
    void testIsNotWhitespace() {
        char ch = ' ';
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for whitespace character"");
        assertEquals(ch, charRange.getStart(), ""Start should be whitespace"");
        assertEquals(ch, charRange.getEnd(), ""End should be whitespace"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for boundary ASCII value"")
    void testIsNotBoundaryASCII() {
        char ch = 0;
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for boundary ASCII value"");
        assertEquals(ch, charRange.getStart(), ""Start should be boundary ASCII value"");
        assertEquals(ch, charRange.getEnd(), ""End should be boundary ASCII value"");

        ch = 127; // ASCII DEL character
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for ASCII DEL character"");
        assertEquals(ch, charRange.getStart(), ""Start should be ASCII DEL"");
        assertEquals(ch, charRange.getEnd(), ""End should be ASCII DEL"");
    }

    @Test
    @DisplayName(""Test creating a negative CharRange for non-ASCII Unicode character"")
    void testIsNotNonASCIIUnicode() {
        char ch = '\u00A9'; // Copyright symbol
        charRange = CharRange.isNot(ch);
        assertTrue(charRange.isNot(), ""CharRange should be inverted for non-ASCII Unicode character"");
        assertEquals(ch, charRange.getStart(), ""Start should be the Unicode character"");
        assertEquals(ch, charRange.getEnd(), ""End should be the Unicode character"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
"org.apache.commons.lang3.CharRange.contains(org.apache.commons.lang3.CharRange)","boolean contains(org.apache.commons.lang3.CharRange)","{
    org.apache.commons.lang3.CharRange range, this;
    unknown $stack10, $stack11, $stack12, $stack13, $stack14, $stack15, $stack16, $stack17, $stack18, $stack19, $stack2, $stack20, $stack21, $stack22, $stack23, $stack3, $stack4, $stack5, $stack6, $stack7, $stack8, $stack9;


    this := @this: org.apache.commons.lang3.CharRange;
    range := @parameter0: org.apache.commons.lang3.CharRange;

    if range != null goto label01;
    $stack23 = new java.lang.IllegalArgumentException;
    specialinvoke $stack23.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(""The Range must not be null"");

    throw $stack23;

  label01:
    $stack2 = this.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack2 == 0 goto label08;
    $stack12 = range.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack12 == 0 goto label04;
    $stack19 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack18 = range.<org.apache.commons.lang3.CharRange: char start>;

    if $stack19 < $stack18 goto label02;
    $stack21 = this.<org.apache.commons.lang3.CharRange: char end>;
    $stack20 = range.<org.apache.commons.lang3.CharRange: char end>;

    if $stack21 > $stack20 goto label02;
    $stack22 = 1;

    goto label03;

  label02:
    $stack22 = 0;

  label03:
    return $stack22;

  label04:
    $stack14 = range.<org.apache.commons.lang3.CharRange: char end>;
    $stack13 = this.<org.apache.commons.lang3.CharRange: char start>;

    if $stack14 < $stack13 goto label05;
    $stack16 = range.<org.apache.commons.lang3.CharRange: char start>;
    $stack15 = this.<org.apache.commons.lang3.CharRange: char end>;

    if $stack16 <= $stack15 goto label06;

  label05:
    $stack17 = 1;

    goto label07;

  label06:
    $stack17 = 0;

  label07:
    return $stack17;

  label08:
    $stack3 = range.<org.apache.commons.lang3.CharRange: boolean negated>;

    if $stack3 == 0 goto label11;
    $stack9 = this.<org.apache.commons.lang3.CharRange: char start>;

    if $stack9 != 0 goto label09;
    $stack10 = this.<org.apache.commons.lang3.CharRange: char end>;

    if $stack10 != 65535 goto label09;
    $stack11 = 1;

    goto label10;

  label09:
    $stack11 = 0;

  label10:
    return $stack11;

  label11:
    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;
    $stack4 = range.<org.apache.commons.lang3.CharRange: char start>;

    if $stack5 > $stack4 goto label12;
    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;
    $stack6 = range.<org.apache.commons.lang3.CharRange: char end>;

    if $stack7 < $stack6 goto label12;
    $stack8 = 1;

    goto label13;

  label12:
    $stack8 = 0;

  label13:
    return $stack8;
}
","```java
package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test contains with overlapping non-negated ranges"")
    void testContainsOverlappingNonNegatedRanges() {
        CharRange otherRange = new CharRange('b', 'y', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'b'-'y'"");
    }

    @Test
    @DisplayName(""Test contains with identical non-negated ranges"")
    void testContainsIdenticalNonNegatedRanges() {
        CharRange otherRange = new CharRange('a', 'z', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain itself"");
    }

    @Test
    @DisplayName(""Test contains with non-overlapping non-negated ranges"")
    void testContainsNonOverlappingNonNegatedRanges() {
        CharRange otherRange = new CharRange('A', 'Z', false);
        assertFalse(charRange.contains(otherRange), ""CharRange 'a'-'z' should not contain 'A'-'Z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test contains with adjacent non-negated ranges"")
    void testContainsAdjacentNonNegatedRanges() {
        CharRange otherRange = new CharRange('a', 'a', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'a'-'a'"");

        otherRange = new CharRange('z', 'z', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'z'-'z'"");
    }

    @Test
    @DisplayName(""Test contains with range outside of non-negated range"")
    void testContainsRangeOutsideNonNegatedRange() {
        CharRange otherRange = new CharRange('y', (char) ('z' + 1), false);
        assertFalse(charRange.contains(otherRange), ""CharRange 'a'-'z' should not contain 'y'-'(z+1)'"");
    }

    @Test
    @DisplayName(""Test contains with negated vs non-negated ranges"")
    void testContainsNegatedVsNonNegatedRanges() {
        CharRange negatedOtherRange = new CharRange('b', 'y', true);
        assertFalse(charRange.contains(negatedOtherRange), ""CharRange 'a'-'z' should not contain negated 'b'-'y'"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test contains with fully negated inclusive range"")
    void testContainsFullyNegatedInclusiveRange() {
        CharRange fullyNegatedRange = new CharRange((char) 0, (char) 65535, true);
        assertTrue(charRange.contains(fullyNegatedRange), ""Non-negated range should contain a fully negated range"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test contains with null range"")
    void testContainsNullRange() {
        CharRange nullRange = null;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            charRange.contains(nullRange);
        }, ""Should throw IllegalArgumentException for null range"");

        assertEquals(""The Range must not be null"", exception.getMessage(), ""Exception message should match expected"");
    }
}
```","package org.apache.commons.lang3;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Rigorous JUnit 5 tests for the CharRange class.
 * Covers typical cases, edge cases, corner cases, and error handling.
 */
class CharRangeTest {

    private CharRange charRange;

    @BeforeEach
    void setUp() {
        charRange = new CharRange('a', 'z', false);
    }

    // TYPICAL CASES

    @Test
    @DisplayName(""Test contains with overlapping non-negated ranges"")
    void testContainsOverlappingNonNegatedRanges() {
        CharRange otherRange = new CharRange('b', 'y', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'b'-'y'"");
    }

    @Test
    @DisplayName(""Test contains with identical non-negated ranges"")
    void testContainsIdenticalNonNegatedRanges() {
        CharRange otherRange = new CharRange('a', 'z', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain itself"");
    }

    @Test
    @DisplayName(""Test contains with non-overlapping non-negated ranges"")
    void testContainsNonOverlappingNonNegatedRanges() {
        CharRange otherRange = new CharRange('A', 'Z', false);
        assertFalse(charRange.contains(otherRange), ""CharRange 'a'-'z' should not contain 'A'-'Z'"");
    }

    // EDGE CASES

    @Test
    @DisplayName(""Test contains with adjacent non-negated ranges"")
    void testContainsAdjacentNonNegatedRanges() {
        CharRange otherRange = new CharRange('a', 'a', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'a'-'a'"");

        otherRange = new CharRange('z', 'z', false);
        assertTrue(charRange.contains(otherRange), ""CharRange 'a'-'z' should contain 'z'-'z'"");
    }

    @Test
    @DisplayName(""Test contains with range outside of non-negated range"")
    void testContainsRangeOutsideNonNegatedRange() {
        CharRange otherRange = new CharRange('y', (char) ('z' + 1), false);
        assertFalse(charRange.contains(otherRange), ""CharRange 'a'-'z' should not contain 'y'-'(z+1)'"");
    }

    @Test
    @DisplayName(""Test contains with negated vs non-negated ranges"")
    void testContainsNegatedVsNonNegatedRanges() {
        CharRange negatedOtherRange = new CharRange('b', 'y', true);
        assertFalse(charRange.contains(negatedOtherRange), ""CharRange 'a'-'z' should not contain negated 'b'-'y'"");
    }

    // CORNER CASES

    @Test
    @DisplayName(""Test contains with fully negated inclusive range"")
    void testContainsFullyNegatedInclusiveRange() {
        CharRange fullyNegatedRange = new CharRange((char) 0, (char) 65535, true);
        assertTrue(charRange.contains(fullyNegatedRange), ""Non-negated range should contain a fully negated range"");
    }

    // ERROR CASES

    @Test
    @DisplayName(""Test contains with null range"")
    void testContainsNullRange() {
        CharRange nullRange = null;
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            charRange.contains(nullRange);
        }, ""Should throw IllegalArgumentException for null range"");

        assertEquals(""The Range must not be null"", exception.getMessage(), ""Exception message should match expected"");
    }
}","lang_1_buggy/src/test/java/org/apache/commons/lang3/CharRangeTest.java"
